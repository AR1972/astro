.comment ******************************************************************
.comment *  Contents family                                               *
.comment ******************************************************************
.comment 12/31/90 Added information on EOF(0) to version differences screen.
.comment 1/9/91 Added links to "Differences from BASICA" from "Unsupported
.comment        Keywords" and "Converting from BASICA" screens.
.comment -- JeffWe (also, deleted comments history to date)
.comment ******************************************************************
.context h.pg1
.context helpSurvivalId
:nSurvival Guide

 \bUsing QBasic:\p

   ş To activate the QBasic menu bar, press Alt.
   ş To activate menus and commands, press the highlighted letter.
   ş To move between menus and commands, use the direction keys.
   ş To get help on a selected keyword, command, or dialog box, press F1.
   ş To exit Help, press Esc.

 \bBrowsing the QBasic Help system:\p

   ş To select one of the following topics, press the Tab key or the first
     letter of the topic. Then press the Enter key to see:

     \i\p\aIndex\i\vhelpIndexId\v\p         The Index for QBasic Help
     \i\i\aContents\vhelpTableId\v\i\p      The Table of Contents for QBasic Help topics
     \i\i\aUsing Help\i\vhelpOnHelpId\v\p    Information on using QBasic Help

 Tip: These topics are also available from the Help menu.
.context helpOnHelpId
:nUsing Help
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Using QBasic Help:

   ş To get help on a Basic keyword, place the cursor on it and press F1
     or click the right mouse button.

   ş To get help on a QBasic menu, command, or dialog box, place the cursor
     on the menu item or <Help> button and press F1.

   ş To view QBasic Help topics, press Alt+H, then press the highlighted
     letter to choose a command.

   ş To move the cursor into the Help window, press Shift+F6.

   ş To scroll the help information, press PgDn or PgUp.

   ş To copy help information (such as a programming example) to the
     View window, use the commands on the QBasic Edit menu.

   ş To close the Help window, press Esc.

 In the Help window, you can display information on:

   ş Help topics (identified by highlighted arrowheads \i \p)

   ş Basic keywords

 To move the cursor to a Help topic, press Tab or the first letter of the
 topic. To display the topic or keyword information, place the cursor
 anywhere on the topic or keyword and press F1 or click the right mouse
 button.

 QBasic saves the last 20 Help topics you viewed. To review them press
 Alt+F1 or click the <Back> button repeatedly.
.context @helpTableId
.context helpTableId
:nTable of Contents
  \bContents\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ÚOrientationÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ÚKeysÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
  ³ \i\p\aUsing Help\vhelpOnHelpId\v\i\p                       ³ ³ \i\p\aShortcut Keys Summary\v@sk\v\i\p        ³
  ³ \i\p\aUsing Menus and Commands\v@sg.men\v\i\p         ³ ³ \i\p\aEditing Keys\v@me\v\i\p                 ³
  ³ \i\p\aUsing a Dialog Box\v@sg.dia\v\i\p               ³ ³ \i\p\aView and Search Keys\v@vk\v\i\p         ³
  ³ \i\p\aSyntax Conventions\vUsingHelpSyntax\v\i\p               ³ ³ \i\p\aRun and Debug Keys\v@dk\v\i\p           ³
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ³ \i\p\aHelp Keys\v@hk\v\i\p                    ³
  ÚUsing QBasicÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
  ³ \i\p\aQBasic Command Line\v@qbas.exe\v\i\p              ³ ÚQuick ReferenceÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
  ³ \i\p\aBasic Character Set\v@fun.character.set\v\i\p              ³ ³ \i\p\aASCII Character Codes\v@ac\v\i\p        ³
  ³ \i\p\aKeywords by Programming Task\v@fk\v\i\p     ³ ³ \i\p\aKeyboard Scan Codes\v@kbsct\v\i\p          ³
  ³ \i\p\aQBasic Environment Limits\v@lqb\v\i\p        ³ ³ \i\p\aRun-Time Error Codes\v@rtect\v\i\p         ³
  ³ \i\p\aVersion Differences\v@vd\v\i\p              ³ ³ \i\p\aCopyright and Trademarks\v@cccp\v\i\p     ³
  ³ \i\p\aConverting BASICA Programs\v@converting_BASIC\v\i\p       ³ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
  ³ \i\p\aBeyond QBasic\v@beyqb\v\i\p                    ³
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
.context @cccp
.context .cccp
:nCopyright and Trademarks
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Information in this document is subject to change without notice and does
  not represent a commitment on the part of Microsoft Corporation. The
  software and/or files described in this document are furnished under a
  license agreement or nondisclosure agreement. The software and/or
  files may be used or copied only in accordance with the terms of the
  agreement. The purchaser may make one copy of the software for backup
  purposes. No part of this online help system may be reproduced or
  transmitted in any form or by any means, electronic or mechanical,
  including photocopying, recording, or information storage and retrieval
  systems, for any purpose, without the written permission of Microsoft
  Corporation.

  RESTRICTED RIGHTS. Use by the U.S. Government subject to restrictions of
  (c) (1) (ii) of DFARS 252.227-7013.

  (C) Copyright Microsoft Corporation, 1987-1992.
      All rights reserved.

  Microsoft, MS, MS-DOS, Microsoft Press, and GW-BASIC are registered
  trademarks.

  Microsoft documentation uses the term "DOS" to refer to both the MS-DOS
  and IBM Personal Computer DOS operating systems. The name of a specific
  operating system is used when it is necessary to note features that are
  unique to the system.

  AT&T is a registered trademark of American Telephone and Telegraph Company.

  Compaq is a registered trademark of Compaq Computer Corporation.

  Hercules is a registered trademark of Hercules Computer Technology.

  IBM is a registered trademark of the International Business Machines
  Corporation.

  Olivetti is a registered trademark of Ing. C. Olivetti.

  WordStar is a registered trademark of MicroPro International Corporation.
.comment *********************************************************************
.comment Orientation nodes
.comment *********************************************************************
.context UsingHelpSyntax
.context @UsingHelpSyntax
:nSyntax Conventions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 KEYWORDS		Items in capital letters are Basic keywords. Keywords
                        are a required part of the statement syntax, unless
                        they are enclosed in brackets.

 placeholders           Items in lowercase are placeholders for information
                        you must supply in the statement (such as a
                        filename$). The QBasic syntax uses data-type suffixes
                        for placeholders that must be a specific data type.
                        Placeholders that can be more than one data type do
                        not have data-type suffixes.

 [optional item]        Items inside square brackets are optional.

 {choice1 | choice2}    Braces and a vertical bar indicate a choice between
                        two or more items. You must use one of the items in
                        the statement unless the braces are enclosed in
                        square brackets.

 item, item, ...        A horizontal three-dot ellipsis means more of the
                        preceding items can be used in a single-line
                        statement.

 Beginning keyword      A vertical three-dot ellipsis is used to describe
 .                      multiline statements (or block-structured
 .                      statements). It means that other statements can be
 .                      used between the beginning and the end of the block.
 Ending keyword
.context @sg.men
:nUsing Menus and Commands
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Use the menu bar at the top of the screen to select menus and commands.

 Menu action          With a mouse...              With a keyboard...
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Display a menu.      Move the mouse pointer to    Press Alt to highlight
                      the menu name, then press    menu letters, then press
                      and release ("click") the    the letter key for the
                      mouse button.                menu you want to display.

 Choose a command.    Click the command name.      Press the letter key that
                                                   matches the highlighted
                                                   letter on the command.

 Cancel a command.    Click outside the menu.      Press Esc.

 Tip: Check the reference bar at the bottom of the screen for help on your
      current task. Choose any item in angle brackets by clicking the item.
.context @sg.dia
:nUsing a Dialog Box
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 QBasic displays dialog boxes when you choose commands that have options.

 Dialog box action    With a mouse...              With a keyboard...
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Select a text box    Move the mouse pointer to    Press Tab until the
 for input.           the text box, then press     cursor is in the text
                      and release ("click") the    box.
                      mouse button.

 Choose an item       Double-click the item.       Highlight the item by
 from a list box.                                  pressing the direction
                                                   keys, then press Enter.

 Choose an option.    Click the option.            Move to an option with
                                                   the direction keys.

 Turn a check box     Click the check box.         Use Tab to move the
 on or off.                                        cursor to the check box,
                                                   then press the Spacebar.

 Choose a command     Click the command button.    Use Tab to move the
 button.                                           cursor to the command
                                                   button, then press Enter.
.comment *********************************************************************
.comment Command Line node
.comment *********************************************************************
.context qbas.exe
.context @qbas.exe
:nQBasic Command Line
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 These options can be typed on the DOS command line following the QBasic
 command:

 \bQBASIC [/B] [/EDITOR] [/G] [/H] [/MBF] [/NOHI] [[/RUN] sourcefile]\p

 Option             Description
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 /B                 Allows the use of a composite (monochrome) monitor with
                    a color graphics card. The /B option displays QBasic in
                    monochrome if you have a color monitor.

 /EDITOR	    Invokes the MS-DOS Editor text editor. Can be
                    abbreviated as /ED.

 /G                 Sets QBasic to update a CGA screen as fast as possible
                    (works only with machines using CGA monitors). If you
                    see snow (dots flickering on the screen) when QBasic
                    updates your screen, your hardware cannot fully support
                    this option. If you prefer a clean screen, restart
                    QBasic without the /G option.

 /H                 Displays the maximum number of lines possible on your
                    hardware.

 /MBF               Causes the QBasic conversion functions (CVS, CVD, MKS$,
                    MKD$) to treat IEEE-format numbers as Microsoft-Binary-
                    format numbers.

 /NOHI              Allows the use of a monitor that does not support high
                    intensity. Not for use with Compaq laptop computers.

 sourcefile         Names the file to load when QBasic starts. To load a
                    file created with GW-BASIC or BASICA, the file must be
                    saved from GW-BASIC or BASICA with the ,A option.

 /RUN sourcefile    Causes QBasic to load and run a program file before
                    displaying it.
.context @fun.character.set
.context .fun.character.set
:nBasic Character Set
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 The Microsoft Basic character set includes alphabetic characters (A-Z, a-z),
 numeric characters (0-9 and A-F or a-f for hexadecimal numbers), and
 special characters. Some characters have special meanings in Basic:

   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄData-Type SuffixesÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³  !  Single-precision                 %  Integer                     ³
   ³  #  Double-precision                 &  Long-integer                ³
   ³  $  String                                                          ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   ÚÄÄÄÄÄMathematical OperatorsÄÄÄÄÄ¿  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄSpecialÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ³  *  Multiplication symbol      ³  ³  '  Comment line (single quote) ³
   ³  -  Minus sign                 ³  ³  ;  Controls PRINT and INPUT    ³
   ³  /  Division symbol (slash)    ³  ³       statement output          ³
   ³  =  Relational operator or     ³  ³  ,  Controls PRINT and INPUT    ³
   ³       assignment symbol        ³  ³       statement output          ³
   ³  >  Greater than               ³  ³  :  Separates multiple state-   ³
   ³  +  Plus sign                  ³  ³       ments on a single line    ³
   ³  .  Decimal point              ³  ³  ?  INPUT statement prompt      ³
   ³  <  Less than                  ³  ³  _  Line continuation underscore³
   ³  \\  Integer division symbol    ³  ³       (reserved for             ³
   ³       (backslash)              ³  ³       compatibility with other  ³
   ³  ^  Exponentiation symbol	    ³  ³       versions of Basic but not ³
   ³       (up arrow or caret)      ³  ³       supported by QBasic)      ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
.comment *******************************************************************
.comment Keys nodes
.comment *******************************************************************
.context .sk
.context @sk
:nShortcut Keys Summary
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  ÚSelectingÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  ÚDeletingÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
  ³ Characters/lines     Shift+Arrow ³  ³ Cut current line          Ctrl+Y ³
  ³ Words           Shift+Ctrl+Arrow ³  ³ Cut to end of line      Ctrl+Q,Y ³
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  ³ Cut selected text      Shift+Del ³
  ÚInsertingÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  ³ Erase selected text          Del ³
  ³ Switch to insert/overstrike  Ins ³  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
  ³ Line above           Home,Ctrl+N ³  ÚCopyingÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
  ³ Line below             End+Enter ³  ³ To Clipboard            Ctrl+Ins ³
  ³ From Clipboard         Shift+Ins ³  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  ÚDebuggingÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
  ÚFindingÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  ³ View output screen            F4 ³
  ³ Search for text         Ctrl+Q,F ³  ³ Continue running              F5 ³
  ³ Repeat find                   F3 ³  ³ Execute to cursor             F7 ³
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  ³ Toggle breakpoint             F9 ³
  ÚGetting HelpÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  ³ Single step                   F8 ³
  ³ On QBasic Help          Shift+F1 ³  ³ Procedure step               F10 ³
  ³ On keywords or topics         F1 ³  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
.context .dk
.context @dk
:nRun and Debug Keys
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Start program execution from beginning               Shift+F5
 Continue program execution from current statement    F5
 Execute program to current cursor position           F7
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Execute next program statement as a single step      F8
 Single step, tracing around procedure calls          F10
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Set or clear a breakpoint                            F9
.context @vk
.context .vk
:nView and Search Keys
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Switch between the output screen and the View window            F4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Display a list of loaded SUB procedures                         F2
 Display the next procedure                                      Shift+F2
 Display the previous procedure                                  Ctrl+F2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Make the next window the active window                          F6
 Make the previous window the active window                      Shift+F6
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Switch between multiple windows and full-screen active window   Ctrl+F10
 Increase size of active window                                  Alt+Plus
 Decrease size of active window                                  Alt+Minus
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Repeat find for same text                                       Ctrl+L or F3
 Search for text                                                 Ctrl+Q,F
 Search for and replace text                                     Ctrl+Q,A
.context @hk
.context .hk
:nHelp Keys
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 View Help for the item where the cursor is located       F1 (or click the
                                                          right mouse button)
 Exit Help                                                Esc
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 View Using Help                                          Shift+F1
 Display the Help menu                                    Alt+H
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Move cursor to next Help topic                           Tab
 Move cursor to previous Help topic                       Shift+Tab
 Move cursor to next topic with starting character        character
 Move cursor to previous topic with starting character    Shift+character
 View previous Help topic (can repeat up to 20 times)     Alt+F1 (or click
                                                          the <Back> button)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 View the next topic in the Help file                     Ctrl+F1
 View the previous topic in the Help file                 Shift+Ctrl+F1
.context @me
:nEditing Keys
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 \bCursor-Movement Keys                            QBasic           WordStar\p
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Character left                                  Left Arrow       Ctrl+S
 Character right                                 Right Arrow      Ctrl+D
 Word left                                       Ctrl+Left Arrow  Ctrl+A
 Word right                                      Ctrl+Right Arrow Ctrl+F
 Line up                                         Up Arrow         Ctrl+E
 Line down                                       Down Arrow       Ctrl+X
 First indentation level of current line         Home
 Beginning of current line                                        Ctrl+Q,S
 Beginning of next line                          Ctrl+Enter       Ctrl+J
 End of line                                     End              Ctrl+Q,D
 Top of window                                                    Ctrl+Q,E
 Bottom of window                                                 Ctrl+Q,X
 Move to next window                             F6
 Increase size of active window                  Alt+Plus
 Decrease size of active window                  Alt+Minus

 \bText-Scrolling Keys                             QBasic           WordStar\p
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Line up                                         Ctrl+Up Arrow    Ctrl+W
 Line down                                       Ctrl+Down Arrow  Ctrl+Z
 Page up                                         PgUp             Ctrl+R
 Page down                                       PgDn             Ctrl+C
 Left one window                                 Ctrl+PgUp
 Right one window                                Ctrl+PgDn
 Set bookmarks (maximum of 4)                    Ctrl+K,0-3
 Go to set bookmarks                             Ctrl+Q,0-3

 \bText-Selection Keys                             QBasic\p
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Character left                                  Shift+Left Arrow
 Character right                                 Shift+Right Arrow
 Word left                                       Shift+Ctrl+Left Arrow
 Word right                                      Shift+Ctrl+Right Arrow
 Current line                                    Shift+Down Arrow
 Line above                                      Shift+Up Arrow
 Screen up                                       Shift+PgUp
 Screen down                                     Shift+PgDn
 To beginning of file                            Shift+Ctrl+Home
 To end of file                                  Shift+Ctrl+End

 \bInsert and Copy Keys                            QBasic           WordStar\p
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Switch between insert and overstrike modes      Ins              Ctrl+V
 Copy selected text to Clipboard                 Ctrl+Ins
 Delete selected text and copy it to Clipboard   Shift+Del
 Delete current line and copy it to Clipboard    Ctrl+Y
 Delete to end of line and copy it to Clipboard                   Ctrl+Q,Y
 Paste the contents of the Clipboard             Shift+Ins
 Insert a blank line below the cursor position   End,Enter
 Insert a blank line above the cursor position                    Home,Ctrl+N
 Insert special characters                       Ctrl+P,Ctrl+key

 \bDelete Keys                                     QBasic           WordStar\p
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Delete one character to left of the cursor      Backspace        Ctrl+H
 Delete one character at the cursor              Del              Ctrl+G
 Delete the rest of the word the cursor is on                     Ctrl+T
 Delete selected text                            Del              Ctrl+G
 Delete leading spaces from selected lines       Shift+Tab
.comment *******************************************************************
.comment Quick Reference nodes
.comment *******************************************************************
.context .fk
.context @fk
:nKeywords by Programming Task
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 Programming task                     Keywords included in this list
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Control program flow                 DO...LOOP, END, EXIT, FOR...NEXT,
                                      IF...THEN...ELSE, GOSUB...RETURN,
                                      GOTO, ON...GOSUB, ON...GOTO,
                                      SELECT CASE, STOP, SYSTEM

 Declare constants and variables      CONST, DATA, DIM, ERASE, OPTION BASE,
                                      READ, REDIM, REM, RESTORE, SWAP,
                                      TYPE...END TYPE

 Define and call Basic procedures     CALL, DECLARE, EXIT, FUNCTION, RUN,
                                      SHELL, SHARED, STATIC, SUB

 Device input/output                  CLS, CSRLIN, INKEY$, INP, INPUT,
                                      KEY (Assignment), LINE INPUT, LOCATE,
                                      LPOS, LPRINT, LPRINT USING, OPEN COM,
                                      OUT, POS, PRINT, PRINT USING, SPC,
                                      SCREEN Function, TAB, VIEW PRINT,
                                      WAIT, WIDTH

 Display graphic images               CIRCLE, COLOR, GET (Graphics), LINE,
                                      PAINT, PALETTE, PCOPY, PMAP, POINT,
                                      PRESET, PSET, PUT (Graphics),
                                      SCREEN Statement, VIEW, WINDOW

 DOS file system commands             CHDIR, KILL, MKDIR, NAME, RMDIR

 File input/output                    CLOSE, EOF, FILEATTR, FREEFILE
                                      GET (File I/O), INPUT, INPUT$,
                                      LINE INPUT, LOC, LOCK, LOF, OPEN,
                                      PUT (File I/O), SEEK Function,
                                      SEEK Statement, UNLOCK, WRITE

 Manage memory                        CLEAR, FRE, PEEK, POKE

 Manipulate strings                   ASC, CHR$, HEX$, INSTR, LCASE$, LEFT$,
                                      LEN, LSET, LTRIM$, MID$ Function, MID$
                                      Statement, OCT$, RIGHT$, RSET, RTRIM$
                                      SPACE$, STR$, STRING$, UCASE$, VAL

 Perform mathematical calculations    ABS, ASC, ATN, CDBL, CINT, CLNG, COS,
                                      CSNG, CVDMBF, CVSMBF, EXP, INT, LOG,
                                      RANDOMIZE, RND, SGN, SIN, SQR, TAN,
                                      TIME$ Function

 Set traps for events and errors      COM, ERDEV, ERDEV$, ERL, ERR, ERROR,
                                      KEY (Event Trapping), ON COM, ON ERROR,
                                      ON KEY, ON PEN, ON PLAY, ON STRIG,
                                      ON TIMER, PEN, PLAY (Event Trapping),
                                      RESUME, RETURN, STRIG, TIMER Function,
                                      TIMER Statement
.context .vd
.context @vd
:nVersion Differences
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

                                             BASICA/GW-BASIC    QBasic
                                             ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍ
 Language Features

     Line numbers                            Required           Optional
     Block IF/THEN/ELSE/END IF               No                 Yes
     Procedural blocks (SUB and FUNCTION)    No                 Yes
     User-defined types (records)            No                 Yes
     SELECT CASE                             No                 Yes
     DO WHILE/UNTIL, LOOP WHILE/UNTIL        No                 Yes
     LONG (32-bit) integers                  No                 Yes
     IEEE-format numbers                     No                 Yes
     Constants                               No                 Yes
     Fixed-length strings                    No                 Yes
     VGA screen modes                        No                 Yes
     Hercules/Olivetti support               No                 Yes
     Recursion                               No                 Yes
     Cassette tape support                   Yes                No
     Code + data capacity                    64K                160K

 Debugging

     Single step                             No                 Yes
     Procedure step                          No                 Yes
     Trace animation                         No                 Yes
     Breakpoints                             No                 Yes
     Edit and continue                       No                 Yes

 Editing

     Instant syntax checking                 No                 Yes
     Diagnostic error messages               No                 Yes
     Instant help on errors                  No                 Yes
     Multiple windows                        No                 Yes
     Mouse support                           No                 Yes
     Menu interface                          No                 Yes
     Wordstar compatible                     No                 Yes
     Code organization                       Linear             Modular
     Document mode for text editing          No                 Yes
     Search/find/replace                     No                 Yes
     Online reference                        None               Full

 See Also    \i\p\aDifferences from BASICA\v@basica.diffs\v\i\p    \i\p\aUnsupported Keywords\v@unsupported\v\i\p
.context @ac
:nASCII Character Codes
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                \bRegular ASCII Chart (character codes 0 - 127)\p
  000   (nul)   016  (dle)   032 sp   048 0   064 @   080 P   096 `   112 p
  001  (soh)   017  (dc1)   033 !    049 1   065 A   081 Q   097 a   113 q
  002  (stx)   018  (dc2)   034 "    050 2   066 B   082 R   098 b   114 r
  003  (etx)   019  (dc3)   035 #    051 3   067 C   083 S   099 c   115 s
  004  (eot)   020  (dc4)   036 $    052 4   068 D   084 T   100 d   116 t
  005  (enq)   021  (nak)   037 %    053 5   069 E   085 U   101 e   117 u
  006  (ack)   022  (syn)   038 &    054 6   070 F   086 V   102 f   118 v
  007  (bel)   023  (etb)   039 '    055 7   071 G   087 W   103 g   119 w
  008  (bs)    024  (can)   040 (    056 8   072 H   088 X   104 h   120 x
  009   (tab)   025  (em)    041 )    057 9   073 I   089 Y   105 i   121 y
  010   (lf)    026   (eof)   042 *    058 :   074 J   090 Z   106 j   122 z
  011  (vt)    027  (esc)   043 +    059 ;   075 K   091 [   107 k   123 {
  012  (np)    028  (fs)    044 ,    060 <   076 L   092 \\   108 l   124 |
  013   (cr)    029  (gs)    045 -    061 =   077 M   093 ]   109 m   125 }
  014  (so)    030  (rs)    046 .    062 >   078 N   094 ^   110 n   126 ~
  015  (si)    031  (us)    047 /    063 ?   079 O   095 _   111 o   127 

               \bExtended ASCII Chart (character codes 128 - 255)\p
    128 €   143    158    172 ¬   186 º   200 È   214 Ö   228 ä   242 ò
    129    144    159 Ÿ   173 ­   187 »   201 É   215 ×   229 å   243 ó
    130 ‚   145 ‘   160     174 ®   188 ¼   202 Ê   216 Ø   230 æ   244 ô
    131 ƒ   146 ’   161 ¡   175 ¯   189 ½   203 Ë   217 Ù   231 ç   245 õ
    132 „   147 “   162 ¢   176 °   190 ¾   204 Ì   218 Ú   232 è   246 ö
    133 …   148 ”   163 £   177 ±   191 ¿   205 Í   219 Û   233 é   247 ÷
    134 †   149 •   164 ¤   178 ²   192 À   206 Î   220 Ü   234 ê   248 ø
    135 ‡   150 –   165 ¥   179 ³   193 Á   207 Ï   221 İ   235 ë   249 ù
    136 ˆ   151 —   166 ¦   180 ´   194 Â   208 Ğ   222 Ş   236 ì   250 ú
    137 ‰   152 ˜   167 §   181 µ   195 Ã   209 Ñ   223 ß   237 í   251 û
    138 Š   153 ™   168 ¨   182 ¶   196 Ä   210 Ò   224 à   238 î   252 ü
    139 ‹   154 š   169 ©   183 ·   197 Å   211 Ó   225 á   239 ï   253 ı
    140 Œ   155 ›   170 ª   184 ¸   198 Æ   212 Ô   226 â   240 ğ   254 ş
    141    156 œ   171 «   185 ¹   199 Ç   213 Õ   227 ã   241 ñ   255
    142    157 

.context .kbsct
.context @kbsct
:nKeyboard Scan Codes
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
     \bKey       Code\p    º     \bKey          Code\p    º     \bKey          Code\p
                       º                          º
     Esc       1       º     A            30      º     Caps Lock    58
     ! or 1    2       º     S            31      º     F1           59
     @ or 2    3       º     D            32      º     F2           60
     # or 3    4       º     F            33      º     F3           61
     $ or 4    5       º     G            34      º     F4           62
     % or 5    6       º     H            35      º     F5           63
     ^ or 6    7       º     J            36      º     F6           64
     & or 7    8       º     K            37      º     F7           65
     * or 8    9       º     L            38      º     F8           66
     ( or 9    10      º     : or ;       39      º     F9           67
     ) or 0    11      º     " or '       40      º     F10          68
     _ or -    12      º     ~ or `       41      º     F11          133
     + or =    13      º     Left Shift   42      º     F12          134
     Bksp      14      º     | or \\       43      º     NumLock      69
     Tab       15      º     Z            44      º     Scroll Lock  70
     Q         16      º     X            45      º     Home or 7    71
     W         17      º     C            46      º     Up or 8      72
     E         18      º     V            47      º     PgUp or 9    73
     R         19      º     B            48      º     Gray -       74
     T         20      º     N            49      º     Left or 4    75
     Y         21      º     M            50      º     Center or 5  76
     U         22      º     < or ,       51      º     Right or 6   77
     I         23      º     > or .       52      º     Gray +       78
     O         24      º     ? or /       53      º     End or 1     79
     P         25      º     Right Shift  54      º     Down or 2    80
     { or [    26      º     Prt Sc or *  55      º     PgDn or 3    81
     } or ]    27      º     Alt          56      º     Ins or 0     82
     Enter     28      º     Spacebar     57      º     Del or .     83
     Ctrl      29      º                          º
.context .rtect
.context @rtect
:nRun-Time Error Codes
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 \bCode    Message\p                    º  \bCode    Message\p
                                    º
 1       NEXT without FOR           º  37      Argument-count mismatch
 2       Syntax error               º  38      Array not defined
 3       RETURN without GOSUB       º  40      Variable required
 4       Out of DATA                º  50      FIELD overflow
 5       Illegal function call      º  51      Internal error
 6       Overflow                   º  52      Bad file name or number
 7       Out of memory              º  53      File not found
 8       Label not defined          º  54      Bad file mode
 9       Subscript out of range     º  55      File already open
 10      Duplicate definition       º  56      FIELD statement active
 11      Division by zero           º  57      Device I/O error
 12      Illegal in direct mode     º  58      File already exists
 13      Type mismatch              º  59      Bad record length
 14      Out of string space        º  61      Disk full
 16      String formula too complex º  62      Input past end of file
 17      Cannot continue            º  63      Bad record number
 18      Function not defined       º  64      Bad file name
 19      No RESUME                  º  67      Too many files
 20      RESUME without error       º  68      Device unavailable
 24      Device timeout             º  69      Communication-buffer overflow
 25      Device fault               º  70      Permission denied
 26      FOR without NEXT           º  71      Disk not ready
 27      Out of paper               º  72      Disk-media error
 29      WHILE without WEND         º  73      Feature unavailable
 30      WEND without WHILE         º  74      Rename across disks
 33      Duplicate label            º  75      Path/File access error
 35      Subprogram not defined     º  76      Path not found
.context .lqb
.context @lqb
:nQBasic Environment Limits
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 This section lists the limits for the following items in the QBasic
 environment:

   \i\p\aName, String, and Number Limits\v@lim.nsn\v\i\p
   \i\p\aArray Limits\v@lim.arr\v\i\p
   \i\p\aProcedure and File Limits\v@lim.pf\v\i\p

 See Also    \i\p\aBeyond QBasic\v@beyqb\v\i\p
.context .lim.nsn
.context @lim.nsn
:nName, String, and Number Limits
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                             Maximum                  Minimum
                             ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ   ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Variable-name length        40 characters             1 character
 String length               32,767 characters         0 characters
 Integers                    32,767                   -32,768
 Long integers               2,147,483,647            -2,147,483,648
 Single-precision numbers:
   Positive                  3.402823E+38              2.802597E-45
   Negative                 -2.802597E-45             -3.402823E+38
 Double-precision numbers:
   Positive                  1.79769313486231D+308     4.940656458412465D-324
   Negative                 -4.940656458412465D-324   -1.79769313486231D+308
.context @lim.arr
:nArray Limits
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                      Maximum                Minimum
                                      ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍ
 Array size (all elements):
   Static                             65,535 bytes (64K)     1 byte
   Dynamic                            65,535 bytes (64K)
 Number of dimensions allowed         60                     1
 Dimensions allowed if unspecified    8                      1
 Array subscript value                32,767                -32,768

   Note: The maximum range between array subscript values is 32,767.
.context @lim.pf
:nProcedure and File Limits
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                               Maximum                 Minimum
                               ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍ
 Procedure size                64K                     0
 Number of arguments passed    60                      0
 Data file numbers             255                     1
 Data file record number       2,147,483,647           1
 Data file record size         32K                     1 byte
 Data file size                Available disk space    0
 Path names                    127 characters          1 character
 Error message numbers         255                     1
.context @converting_BASIC
:nConverting BASICA Programs
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  Remember the following points when converting BASICA programs to QBasic:

  ş Save the BASICA program in ASCII format. QBasic cannot use programs that
    are saved in BASICA's binary format.

  ş Use the /MBF command option when starting QBasic. The /MBF option enables
    QBasic to read and write BASICA data files.

  ş Change CALL statements to CALL ABSOLUTE. The BASICA CALL statement is
    equivalent to QBasic's CALL ABSOLUTE.

  In addition, you may want to use REMLINE.BAS to remove unnecessary line
  numbers from the programs you are converting. QBasic does not require
  line numbers and removing them can improve a program's readability.

 See Also    \i\p\aDifferences from BASICA\v@basica.diffs\v\i\p    \i\p\aUnsupported Keywords\v@unsupported\v\i\p
             \i\p\aVersion Differences\v@vd\v\i\p
.context beyqb
.context @beyqb
:nBeyond QBasic
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 QBasic is an easy-to-use environment for creating Basic programs.
 The following table lists some solutions if you need to go beyond QBasic.

 If you need                     You can
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ     ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

 Fast program execution 	 Use a Basic compiler (such as Microsoft
				 Visual Basic for MS-DOS) to translate your
				 Basic code into native machine code.

 To build programs that 	 Use a Basic development environment that
 require over 160K of memory     supports creating large programs.

 To distribute your programs	 Use Microsoft Visual Basic for MS-DOS or
                                 another Basic compiler to create stand-alone
                                 applications from your QBasic code. This
                                 allows you to distribute your programs and
                                 eliminates the need for QBasic to be present.

 To add mouse control to your    Use Microsoft Visual Basic for MS-DOS, which
 application or create a         has built-in mouse support and tools to help
 standard user interface.        you create an attractive user interface.

 Contact your local software dealer if you want more information about Basic
 programming products. If you want to learn more about programming with Basic,
 consult the following Microsoft Press books or other books for information:

   ş "Running QBasic" by Michael Halvorson and David Rygmyr (1991).
   ş "QBasic: Programmer's Quick Reference" by Kris Jamsa (1991).
   ş "The Waite Group's QBasic Reference Plus" by Waite, Prata, et al.
     (1991).
   ş "Do It Yourself Visual Basic for MS-DOS" by WIlliam J. Orvis (1992).
   ş "Microsoft Guide to Visual Basic for MS-DOS Programming" by Peter G.
      Aitken (1992).
   ş "Peter Norton's Guide to Visual Basic for MS-DOS Programming" by Steve
      Holzer and the Peter Norton Computing Group (1992).
   ş "Teach Yourself Visual Basic for MS-DOS" by Chuck Butkus(1992).
   ş "Visual Basic for MS-DOS by Example" by D.F. Scott (1992).
   ş "Visual Basic for MS-DOS Inside and Out" by David I. Schneider and
      Gary Cornell (1992).
   ş "Visual Basic for MS-DOS Uncovered" by Bryon Scott, et al.(1992).

.context @unsupported
.context ALIAS
.context EVENT
.context LOCAL
.context BYVAL
.context $INCLUDE
.context SADD
.context SETMEM
.context CDECL
.context Int86
.context Interrupt
.context SIGNAL
.context COMMAND$
.context Int86X
.context InterruptX
.context UEVENT
.context AUTO
.context NEW
.context CONT
.context LLIST
.context RENUM
.context LOAD
.context SAVE
.context DELETE
.context MERGE
.context USR
.context EDIT
.context MOTOR
:nUnsupported Keywords
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 The following QuickBasic keywords are not supported in QBasic:

     ALIAS       EVENT       LOCAL         SETMEM
     BYVAL       $INCLUDE    SADD          SIGNAL
     CDECL       Int86       Interrupt     UEVENT
     COMMAND$    Int86X      InterruptX

 The following GW-BASIC/BASICA keywords are not supported in QBasic:

     AUTO        EDIT        MERGE         RENUM
     CONT        LIST        MOTOR         SAVE
     DEF USR     LLIST       NEW           USR
     DELETE      LOAD

 See Also    \i\p\aConverting BASICA Programs\v@converting_BASIC\v\i\p    \i\p\aDifferences from BASICA\v@basica.diffs\v\i\p
             \i\p\aVersion Differences\v@vd\v\i\p
.context @basica.diffs
:nDifferences from BASICA
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 The following keywords behave differently in QBasic than in BASICA:

 \bBSAVE, BLOAD\p     QBasic does not support the cassette device with BSAVE
                  and BLOAD, and memory locations may be different.

 \bCALL ABSOLUTE\p    Assembly language programs invoked from BASICA that have
                  string arguments must be revised for QBasic because QBasic
                  string descriptors are 4 bytes long. The 4 bytes are the
                  low byte and high byte of the string length followed by
                  the low byte and high byte of the string address.

 \bCHAIN\p            QBasic does not allow you to specify a line number with
                  CHAIN and does not support the ALL, MERGE, or DELETE
                  options in BASICA.

 \bCOMMON, DECLARE\p  QBasic does not allow executable statements to appear
                  before COMMON and DECLARE statements.

 \bDEFtype\p          If BASICA encounters a variable without an explicit type
                  (indicated by !, #, &, $, or %), it uses the default type
                  set by the most recent DEFtype statement. For example, the
                  type of the variable IFLAG changes from integer to single
                  precision in the following BASICA code fragment:

                      10  DEFINT I
                      20  PRINT IFLAG
                      30  DEFSNG I
                      40  GOTO 20

                  In QBasic, a variable's type cannot be changed after it
                  appears in a program.

 \bDIM\p              All arrays in BASICA are dynamic because BASICA always
                  allocates array storage while a program runs. In QBasic,
                  DIM can declare either a static or dynamic array.

 \bDRAW, PLAY\p       DRAW and PLAY statements in BASICA that use variables or
                  other command strings within command strings must be
                  modified for QBasic. Use the VARPTR$ function, which
                  returns a string representation of the variable's address:

                  BASICA Statement      QBasic Equivalent
                  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                  DRAW "Xcmdstring$"    DRAW "X" + VARPTR$ (cmdstring$)
                  DRAW "TA = angle"     DRAW "TA =" + VARPTR$(angle)

 \bEOF\p              When you direct input from a file to a BASICA program,
                  EOF(0) returns true at the end of the input file.
                  In QBasic, EOF(0) returns true after the next record is
                  read past the end of the input file. For example, the
                  following program runs in BASICA, but generates an
                  "Input past end of file" error message in QBasic:

                      5  WHILE NOT EOF(0)
                      10 LINE INPUT ; A$
                      15 WEND

 \bFIELD\p            When a random-access file is closed in BASICA with a CLOSE
                  or RESET statement, field variables retain the last value
                  assigned to them by a GET statement. In QBasic, all field
                  variables are reset to null strings.

 See Also    \i\p\aConverting BASICA Programs\v@converting_BASIC\v\i\p   \i\p\aUnsupported Keywords\v@unsupported\v\i\p
             \i\p\aVersion Differences\v@vd\v\i\p
.comment ******************************************************************
.comment *  File I/O Family - QBasic                                      *
.comment ******************************************************************
.comment * 1/10/91 Cleaned up comments.
.comment *   -- JeffWe
.comment ******************************************************************
.context BLOAD
.context @BLOAD
.context BSAVE
.context @BSAVE
:nBSAVE, BLOAD Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
BSAVE copies the contents of an area of memory to a file.
BLOAD loads a file created by BSAVE into memory.

\bBSAVE filespec$, offset%, length&\p
\bBLOAD filespec$[,offset%]\p

    ş \bfilespec$\p    For BSAVE, a file to which an area of memory (a
                   byte-for-byte memory image) is copied. For BLOAD,
                   a memory-image file created by a previous BSAVE.
    ş \boffset%\p      For BSAVE, the offset of the starting address of the
                   area of memory being saved. For BLOAD, the offset of
                   the address where loading starts.
    ş \blength&\p      The number of bytes to copy (from 0 through 65,535).

    ş The starting address of the memory area saved or loaded is determined
      by the offset and the most recent DEF SEG statement.

See Also    \i\p\aDEF SEG\v@SEG\v\i\p    \i\p\aVARPTR, VARSEG\v@VARSEG\v\i\p    \i\p\aDifferences from BASICA\v@basica.diffs\v\i\p
.context CHDIR
.context @CHDIR
.context MKDIR
.context @MKDIR
.context RMDIR
.context @RMDIR
.context FILES
.context @FILES
:nCHDIR, MKDIR, RMDIR, FILES Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
CHDIR changes a drive's default directory. MKDIR creates a subdirectory.
MRDIR removes a subdirectory. FILES displays the contents of the current
directory or a specified directory.

\bCHDIR pathname$\p
\bMKDIR pathname$\p
\bRMDIR pathname$\p
\bFILES [filespec$]\p

    ş \bpathname$\p    The path of the new default directory, subdirectory to
                   create, or subdirectory to remove.
    ş \bfilespec$\p    A filename or path (may include a drive and DOS wildcard
                   characters). If you don't specify a filespec$, FILES
                   displays all files in the current directory.

Example:
    MKDIR "C:\\TEMP\\TEST"
    CHDIR "C:\\TEMP"
    FILES
    RMDIR "TEST"
.context CLOSE
.context @CLOSE
:nCLOSE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Closes one or more open files or devices.

\bCLOSE [[#]filenumber%[,[#]filenumber%]...]\p

    ş \bfilenumber%\p    The number of an open file or device.

    ş CLOSE with no arguments closes all open files and devices.

Example:
    CLS
    INPUT "Enter filename: ", n$
    OPEN n$ FOR OUTPUT AS #1
    PRINT #1, "This is saved to the file."
    CLOSE
    OPEN n$ FOR INPUT AS #1
    INPUT #1, a$
    PRINT "Read from file: "; a$
    CLOSE

See Also    \i\p\aEND\v@END\v\i\p    \i\p\aOPEN\v@OPEN\v\i\p    \i\p\aRESET\v@RESET\v\i\p    \i\p\aSTOP\v@STOP\v\i\p
.context EOF
.context @EOF
:nEOF Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Tests for the end of a file. EOF returns true (nonzero) if the end of a file
has been reached.

\bEOF(filenumber%)\p

    ş \bfilenumber%\p    The number of an open file.

Example:
    CLS
    OPEN "TEST.DAT" FOR OUTPUT AS #1
    FOR i% = 1 TO 10
        WRITE #1, i%, 2 * i%, 5 * i%
    NEXT i%
    CLOSE #1
    OPEN "TEST.DAT" FOR INPUT AS #1
    DO
        LINE INPUT #1, a$
        PRINT a$
    LOOP UNTIL (EOF(1))

See Also    \i\p\aCLOSE\v@CLOSE\v\i\p    \i\p\aLOC\v@LOC\v\i\p    \i\p\aLOF\v@LOF\v\i\p    \i\p\aOPEN\v@OPEN\v\i\p
.context ERDEV
.context @ERDEV
.context ERDEV$
.context @ERDEV$
:nERDEV, ERDEV$ Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
ERDEV returns an error code from the last device that generated a critical
error. ERDEV$ returns the name of the device that generated the error.

\bERDEV\p
\bERDEV$\p

    ş The low byte of the value returned by ERDEV contains the DOS error
      code. The high byte contains device-attribute information.

\i\p\aExample\v@errhand.ex\v\i\p

See Also    \i\p\aERR, ERL\v@ERR\v\i\p    \i\p\aON ERROR\v@onerr\v\i\p
.context FIELD
.context @FIELD
:nFIELD Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Allocates space for variables in a random-access file buffer.

\bFIELD [#]filenumber%, fieldwidth% AS stringvariable$\p
                    \b[,fieldwidth% AS stringvariable$] ...\p

    ş \bfilenumber%\p        The number of an open file.
    ş \bfieldwidth%\p        The number of characters in the field.
    ş \bstringvariable$\p    A variable that identifies the field and contains
                         field data.

    ş Record variables usually provide a better way to handle record data.

Example:
    OPEN "FILEDAT.DAT" FOR RANDOM AS #1 LEN = 80
    FIELD #1, 30 AS name$, 50 AS address$

See Also    \i\p\aGET, PUT\v@GET\v\i\p    \i\p\aLSET, RSET\v@LSET\v\i\p    \i\p\aTYPE\v@TYPE\v\i\p    \i\p\aDifferences from BASICA\v@basica.diffs\v\i\p
.context FILEATTR
.context @FILEATTR
:nFILEATTR Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns information about an open file.

\bFILEATTR(filenumber%,attribute%)\p

    ş \bfilenumber%\p    The number of an open file.
    ş \battribute%\p     Specifies the type of information to return. When
                     attribute% is 1, FILEATTR returns a value indicating
                     the file's access mode:

                     Value   Mode
                     ÍÍÍÍÍ   ÍÍÍÍÍÍ
                     1       Input
                     2       Output
                     4       Random
                     8       Append
                     32      Binary

                     When attribute% is 2, FILEATTR returns the DOS file
                     handle.

Example:
    OPEN "TEST.DAT" FOR BINARY AS #1
    PRINT FILEATTR(1, 1)
    CLOSE

See Also    \i\p\aOPEN\v@OPEN\v\i\p
.context FREEFILE
.context @FREEFILE
:nFREEFILE Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the next valid unused file number.

\bFREEFILE\p

Example:
    OPEN "TEST.DAT" FOR OUTPUT AS #1
    PRINT "Next file number: "; FREEFILE
    CLOSE

See Also    \i\p\aOPEN\v@OPEN\v\i\p
.context GET
.context @GET
.context PUT
.context @PUT
:nGET, PUT Statements (File I/O)
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
GET reads from a file into a random-access buffer or variable.
PUT writes a variable or random-access buffer to a file.

\bGET [#]filenumber%[,[recordnumber&][,variable]]\p
\bPUT [#]filenumber%[,[recordnumber&][,variable]]\p

    ş \bfilenumber%\p      The number of an open file.
    ş \brecordnumber&\p    For random-access files, the number of the record to
                       read or write. For binary-mode files, the byte
                       position where reading or writing starts.
    ş \bvariable\p         For GET, a variable used to receive input from the
                       file. For PUT, a variable that contains output to
                       write to the file. The variable is usually a variable
                       of a user-defined data type.

Example:
    TYPE TestRecord
        Student AS STRING * 20
        Score AS SINGLE
    END TYPE
    DIM MyClass AS TestRecord
    OPEN "FINAL.DAT" FOR RANDOM AS #1 LEN = LEN(MyClass)
    MyClass.Student = "MarySa"
    MyClass.Score = 99
    PUT #1, 1, MyClass
    CLOSE #1
    OPEN "FINAL.DAT" FOR RANDOM AS #1 LEN = LEN(MyClass)
    GET #1, 1, MyClass
    PRINT "STUDENT:", MyClass.Student
    PRINT "SCORE:", MyClass.Score
    CLOSE #1
    KILL "FINAL.DAT"

See Also    \i\p\aFIELD\v@FIELD\v\i\p    \i\p\aGET, PUT (Graphics)\v@ggx\v\i\p    \i\p\aLSET, RSET\v@LSET\v\i\p
            \i\p\aMKn$, CVn Functions\v@MKI$\v\i\p               \i\p\aTYPE\v@TYPE\v\i\p
.context INPUT$
.context @INPUT$
:nINPUT$ Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns a string of characters read from a specified file.

\bINPUT$(n[,[#]filenumber%])\p

    ş \bn\p              The number of characters (bytes) to read.
    ş \bfilenumber%\p    The number of an open file. If filenumber% is
                     omitted, INPUT$ reads from the keyboard.

Example:
    OPEN "TEST.DAT" FOR OUTPUT AS #1
    PRINT #1, "The text"
    CLOSE
    OPEN "TEST.DAT" FOR INPUT AS #1
    PRINT INPUT$(3, 1)        'Print first 3 characters.
    CLOSE

See Also    \i\p\aINPUT, LINE INPUT\v@INPUT\v\i\p
.context IOCTL
.context @IOCTL
.context IOCTL$
.context @IOCTL$
:nIOCTL Statement, IOCTL$ Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
IOCTL transmits a control string to a device driver.
IOCTL$ returns current status information from a device driver.

\bIOCTL [#]filenumber%, string$\p
\bIOCTL$([#]filenumber%)\p

    ş \bfilenumber%\p    The number of an open device.
    ş \bstring$\p        The control string sent to the device.

    ş IOCTL control strings and the information returned by IOCTL$ depend
      on the device driver. See your device-driver documentation for
      information about IOCTL control strings and what is returned by IOCTL$.
.context LOC
.context @LOC
:nLOC Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the current position within a file.

\bLOC(filenumber%)\p

    ş \bfilenumber%\p    The number of an open file or device.

    ş For binary files, LOC returns the position of the last byte read or
      written.
    ş For random-access files, LOC returns the number of the last record
      read from or written to the file.
    ş For sequential files, LOC returns the current byte position in the
      file, divided by 128.

Example:
    OPEN "TEST.DAT" FOR RANDOM AS #1
    FOR i% = 1 TO 10
       PUT #1, , i%
    NEXT i%
    SEEK #1, 2
    GET #1, , i%
    PRINT "Data: "; i%; " Current record: "; LOC(1); " Next: "; SEEK(1)

See Also    \i\p\aEOF\v@EOF\v\i\p    \i\p\aSEEK\v@SEEK\v\i\p
.context LOCK
.context @LOCK
.context UNLOCK
.context @UNLOCK
:nLOCK, UNLOCK Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
LOCK limits or prevents access to a file by a network process.
UNLOCK releases the locks imposed by the last LOCK statement.

\bLOCK [#]filenumber% [,{record& | [start&] TO end&}]\p
\bUNLOCK [#]filenumber% [,{record& | [start&] TO end&}]\p

    ş \bfilenumber%\p        The number of an open file.
    ş \brecord&\p            For random-access files, the number of a record to
                         lock, relative to the first record in the file.
                         For binary files, the number of a byte to lock,
                         relative to the first byte in the file.
    ş \bstart&\p and \bend&\p    The numbers of the first and last records or bytes
                         in a range of records or bytes to lock or unlock.

    ş For sequential files, LOCK and UNLOCK affect the entire file.

Example:
    'This example runs only in a network environment.
    OPEN "TEST.DAT" FOR RANDOM AS #1
    FOR i% = 1 TO 10
        PUT #1, , i%
    NEXT i%
    LOCK #1, 2         'Lock record 2.
    GET #1, 2, i%
    UNLOCK #1, 2       'Unlock record 2.
.context LOF
.context @LOF
:nLOF Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the length of a file in bytes.

\bLOF(filenumber%)\p

    ş \bfilenumber%\p    The number of an open file.

Example:
    INPUT "Enter filename: "; f$
    OPEN f$ FOR BINARY AS #1
    PRINT "File length = "; LOF(1)
    CLOSE
.context LSET
.context @LSET
.context RSET
.context @RSET
:nLSET, RSET Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
LSET and RSET move data into a random-access file buffer (in preparation for
a PUT statement) and left- or right-justify the value of a string variable.
LSET also copies the contents of one record variable to another.

\bLSET stringvariable$=stringexpression$\p
\bRSET stringvariable$=stringexpression$\p
\bLSET recordvariable1=recordvariable2\p

    ş \bstringvariable$\p      Any string variable or a random-access file field
                           defined in a FIELD statement.
    ş \bstringexpression$\p    For LSET, the left-justified version of
                           stringvariable$. For RSET, the right-justified
                           version of stringvariable$.
    ş \brecordvariable1\p      Record variables of any user-defined data type.
      \brecordvariable2\p      Use LSET to assign a record variable of one data
                           type to a different user-defined data type.

Example:
    OPEN "FILEDAT.DAT" FOR RANDOM AS #1 LEN = 10
    FIELD #1, 5 AS Ls1$, 5 AS Rs1$
    LSET Ls1$ = "LSET"
    RSET Rs1$ = "RSET"
    PUT #1, 1
    CLOSE #1
    OPEN "FILEDAT.DAT" FOR RANDOM AS #1 LEN = 10
    FIELD #1, 5 AS Ls2$, 5 AS Rs2$
    GET #1, 1
    PRINT "*" + Ls2$ + "*", "*" + Rs2$ + "*"
    CLOSE #1

See Also    \i\p\aFIELD\v@FIELD\v\i\p    \i\p\aGET, PUT\v@PUT\v\i\p
.context NAME
.context @NAME
:nNAME Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Renames a file or directory.

\bNAME oldspec$ AS newspec$\p

    ş \boldspec$\p and \bnewspec$\p    The name of an existing file and the new name
                               for the file. Each name may include a path.

Example:
    INPUT "Old Name: "; OldFN$
    INPUT "New Name: "; NewFN$
    NAME OldFN$ AS NewFN$

See Also    \i\p\aFILES\v@FILES\v\i\p
.context OPEN
.context @OPEN
:nOPEN Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Opens a file or device.

\bOPEN file$ [FOR mode] [ACCESS access] [lock] AS [#]filenumber% [LEN=reclen%]\p

    ş \bfile$\p          The name of the file or device. The file name may
                     include a drive and path.
    ş \bmode\p           One of the following file modes: APPEND, BINARY, INPUT,
                     OUTPUT, or RANDOM. See \i\p\aOPEN Statement File Modes\v@APPEND\v\i\p.
    ş \baccess\p         In network environments, specifies whether the file is
                     opened for READ, WRITE, or READ WRITE access.
                     See \i\p\aOPEN Statement ACCESS Clause\v@ACCESS\v\i\p.
    ş \block\p           Specifies the file locking in network environments:
                     SHARED, LOCK READ, LOCK WRITE, LOCK READ WRITE.
    ş \bfilenumber%\p    A number in the range 1 through 255 that identifies the
                     file while it is open.
    ş \breclen%\p        For random-access files, the record length (default is
                     128 bytes). For sequential files, the number of
                     characters buffered (default is 512 bytes).

Example:
    INPUT "Enter Filename: "; n$
    OPEN n$ FOR OUTPUT AS #1
    PRINT #1, "This is saved to the file."
    CLOSE
    OPEN n$ FOR INPUT AS #1
    INPUT #1, a$
    PRINT "Read from file: "; a$
    CLOSE

See Also    \i\p\aCLOSE\v@CLOSE\v\i\p    \i\p\aFREEFILE\v@FREEFILE\v\i\p    \i\p\aOPEN COM\v@opcom\v\i\p    \i\p\aTYPE\v@TYPE\v\i\p
            \i\p\aOPEN Statement Alternate Syntax\v@openalt\v\i\p
.context APPEND
.context @APPEND
.context BINARY
.context @BINARY
.context OUTPUT
.context @OUTPUT
.context RANDOM
.context @RANDOM
:nOPEN Statement File Modes
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
The APPEND, BINARY, INPUT, OUTPUT, and RANDOM keywords are used in the
OPEN statement to specify file modes. INPUT, OUTPUT, and RANDOM are also
used in the OPEN COM statement.

    ş APPEND specifies that the file is to be opened for sequential output
      and sets the file pointer to the end of the file. A PRINT # or
      WRITE # statement then extends (appends to) the file.
    ş BINARY specifies a binary-file mode. In binary mode, you can read or
      write information to any byte position in the file using GET or PUT
      statements.
    ş INPUT specifies that the file is opened for sequential input.
    ş OUTPUT specifies that the file is opened for sequential output.
    ş RANDOM specifies that the file is opened in random-access file mode.
      RANDOM is the default file mode.

See Also    \i\p\aOPEN\v@OPEN\v\i\p    \i\p\aOPEN COM\v@opcom\v\i\p    \i\p\aPRINT, LPRINT\v@PRINT\v\i\p    \i\p\aWRITE\v@WRITE\v\i\p
.context ACCESS
.context @ACCESS
:nOPEN Statement ACCESS Clause
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Specifies the type of access users have to an opened file.

\bACCESS {READ | WRITE | READ WRITE}\p

    ş \bREAD\p          Opens a file for reading only.
    ş \bWRITE\p         Opens a file for writing only.
    ş \bREAD WRITE\p    Opens a file for both reading and writing. READ WRITE
                    mode is valid only for random-access and binary-mode
                    files, and files opened for APPEND (sequential access).

See Also    \i\p\aOPEN\v@OPEN\v\i\p
.context @openalt
.context .openalt
:nOPEN Statement Alternate Syntax
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
\bOPEN mode2$,[#]filenum%,file$[,reclen%]\p

    ş \bmode2$\p      A string expression that begins with one of the
                  following characters and specifies the file mode:
                    O    Sequential output mode.
                    I    Sequential input mode.
                    R    Random-access file input/output mode.
                    B    Binary-file mode.
                    A    Sequential output mode. Sets the file pointer to
                         the end of the file and the record number to the
                         last record of the file. A PRINT # or WRITE #
                         statement extends (appends to) the file.
    ş \bfilenum%\p    A number in the range 1 through 255 that identifies
                  the file while it is open.
    ş \bfile$\p       The name of the file (may include drive and path).
    ş \breclen%\p     For random-access files, the record length in bytes.
                  For sequential files, the number of characters buffered.

    ş QBasic supports this syntax for compatibility with programs written
      in earlier versions of BASIC.

See Also    \i\p\aOPEN\v@OPEN\v\i\p
.context RESET
.context @RESET
:nRESET Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Closes all open files and devices.

\bRESET\p

See Also    \i\p\aCLOSE\v@CLOSE\v\i\p    \i\p\aEND\v@END\v\i\p    \i\p\aOPEN\v@OPEN\v\i\p    \i\p\aSTOP\v@STOP\v\i\p
.context SEEK
.context @SEEK
:nSEEK Function and Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
The SEEK function returns the current file position.
The SEEK statement sets the file position for the next read or write.

\bSEEK(filenumber%)\p
\bSEEK [#]filenumber%, position&\p

    ş \bfilenumber%\p    The number of an open file.
    ş \bposition&\p      The position where the next read or write occurs. For
                     random-access files, a record number. For other files,
                     the byte position relative to the beginning of the file.
                     The first byte is at position 1.

Example:
    OPEN "TEST.DAT" FOR RANDOM AS #1
    FOR i% = 1 TO 10
        PUT #1, , i%
    NEXT i%
    SEEK #1, 2
    GET #1, , i%
    PRINT "Data: "; i%; " Current record: "; LOC(1); " Next: "; SEEK(1)

See Also    \i\p\aGET, PUT\v@GET\v\i\p    \i\p\aOPEN\v@OPEN\v\i\p
.context WRITE
.context @WRITE
:nWRITE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Writes data to the screen or a sequential file.

\bWRITE [[#]filenumber%,] expressionlist\p

    ş \bfilenumber%\p       The number of an open sequential file. If the file
                        number is omitted, WRITE writes to the screen.
    ş \bexpressionlist\p    One or more variables or expressions, separated by
                        commas, whose values are written to the screen or
                        file.

    ş WRITE inserts commas between items and quotation marks around strings
      as they are written. WRITE writes values to a file in a form that can
      be read by the INPUT statement.

Example:
    CLS
    OPEN "LIST" FOR OUTPUT AS #1
    DO
        INPUT "   NAME:       ", Name$
        INPUT "   AGE:        ", Age$
        WRITE #1, Name$, Age$
        INPUT "Add another entry"; R$
    LOOP WHILE UCASE$(R$) = "Y"
    CLOSE #1
    'Print the file to the screen.
    OPEN "LIST" FOR INPUT AS #1
    CLS
    PRINT "Entries in file:": PRINT
    DO WHILE NOT EOF(1)
        INPUT #1, Rec1$, Rec2$   'Read entries from file.
        PRINT Rec1$, Rec2$       'Print the entries on the screen.
    LOOP
    CLOSE #1
    KILL "LIST"

See Also    \i\p\aINPUT, LINE INPUT\v@INPUT\v\i\p    \i\p\aOPEN\v@OPEN\v\i\p    \i\p\aPRINT, LPRINT\v@PRINT\v\i\p
.comment *******************************************************************
.comment *  AS Keyword
.comment *******************************************************************
.context AS
.context @AS
:nAS Keyword
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Performs different actions as part of several statements:

    ş Specifies a variable type when used in the COMMON, DECLARE, DEF FN,
      DIM, FUNCTION, REDIM, SHARED, STATIC, and SUB statements.
    ş Specifies an element type in a user-defined data type when used in
      the TYPE statement.
    ş Assigns a file number to a file or device when used in the OPEN
      statement.
    ş Specifies a field name when used in the FIELD statement.
    ş Specifies a new file name when used in the NAME statement.

See Also    \i\p\aCOMMON\v@COMMON\v\i\p    \i\p\aDECLARE\v@DECLARE\v\i\p     \i\p\aDEF FN\v@DEF\v\i\p    \i\p\aDIM, REDIM\v@DIM\v\i\p
            \i\p\aFIELD\v@FIELD\v\i\p     \i\p\aFUNCTION\v@FUNCTION\v\i\p    \i\p\aNAME\v@NAME\v\i\p      \i\p\aOPEN\v@OPEN\v\i\p
            \i\p\aSHARED, STATIC\v@SHARED\v\i\p          \i\p\aSUB\v@SUB\v\i\p       \i\p\aTYPE\v@TYPE\v\i\p
.comment ******************************************************************
.comment *  Device I/O Family - QBasic                                    *
.comment ******************************************************************
.comment * 01/09/91 Cleaned up comments.
.comment *  -- JeffWe
.comment ******************************************************************
.context BEEP
.context @BEEP
:nBEEP Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Generates a beep sound from your computer's speaker.

\bBEEP\p
.context CLS
.context @CLS
:nCLS Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Clears the screen.

\bCLS [{0 | 1 | 2}]\p

    CLS      Clears either the text or graphics viewport. If a graphics
             viewport has been set (using VIEW), clears only the graphics
             viewport. Otherwise, clears the text viewport or entire screen.
    CLS 0    Clears the screen of all text and graphics.
    CLS 1    Clears the graphics viewport or the entire screen if no graphics
             viewport has been set.
    CLS 2    Clears the text viewport.

See Also    \i\p\aVIEW\v@VIEW\v\i\p    \i\p\aVIEW PRINT\v@vupri\v\i\p    \i\p\aWINDOW\v@WINDOW\v\i\p
.context INKEY$
.context @INKEY$
:nINKEY$ Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Reads a character from the keyboard.

\bINKEY$\p

    ş INKEY$ returns a null string if there is no character to return.
    ş For standard keys, INKEY$ returns a 1-byte string containing the
      character read.
    ş For extended keys, INKEY$ returns a 2-byte string made up of the null
      character (ASCII 0) and the keyboard scan code.

Example:
    PRINT "Press Esc to exit..."
    DO
    LOOP UNTIL INKEY$ = CHR$(27)    '27 is the ASCII code for Esc.

See Also    \i\p\aKeyboard Scan Codes\v@kbsct\v\i\p
.context INP
.context @INP
.context OUT
.context @OUT
:nINP Function, OUT Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
INP returns a byte read from a hardware I/O port.
OUT sends a byte to a hardware I/O port.

\bINP(port%)\p
\bOUT port%, data%\p

    ş \bport%\p     A number in the range 0 through 65,535 that identifies
                the port.
    ş \bdata%\p     A numeric expression in the range 0 through 255 to send
                to the port.

Example:
    x% = INP(&H3FC)          'Read COM1 Modem Control Register.
    OUT &H3FC, (x% XOR 1)    'Change Data Terminal Ready bit.

See Also    \i\p\aWAIT\v@WAIT\v\i\p
.context INPUT
.context @INPUT
:nINPUT, LINE INPUT Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
INPUT reads input from the keyboard or a file. LINE INPUT reads a line of
up to 255 characters from the keyboard or a file.

\bINPUT [;] ["prompt"{; | ,}] variablelist\p
\bLINE INPUT [;] ["prompt";] variable$\p
\bINPUT #filenumber%, variablelist\p
\bLINE INPUT #filenumber%, variable$\p

    ş \bprompt\p          An optional literal string that is displayed before
                      the user enters data. A semicolon after prompt appends
                      a question mark to the prompt string.
    ş \bvariablelist\p    One or more variables, separated by commas, in which
                      data entered from the keyboard or read from a file is
                      stored. Variable names can consist of up to 40
                      characters and must begin with a letter. Valid
                      characters are A-Z, 0-9, and period (.).
    ş \bvariable$\p       Holds a line of characters entered from the keyboard
                      or read from a file.
    ş \bfilenumber%\p     The number of an open file.

    ş INPUT uses a comma as a separator between entries.
      LINE INPUT reads all characters up to a carriage return.
    ş For keyboard input, a semicolon immediately after INPUT keeps the
      cursor on the same line after the user presses the Enter key.

Example:
    CLS
    OPEN "LIST" FOR OUTPUT AS #1
    DO
        INPUT "   NAME:       ", Name$  'Read entries from the keyboard.
        INPUT "   AGE:        ", Age$
        WRITE #1, Name$, Age$
        INPUT "Add another entry"; R$
    LOOP WHILE UCASE$(R$) = "Y"
    CLOSE #1
    'Echo the file back.
    OPEN "LIST" FOR INPUT AS #1
    CLS
    PRINT "Entries in file:": PRINT
    DO WHILE NOT EOF(1)
        LINE INPUT #1, REC$  'Read entries from the file.
        PRINT REC$           'Print the entries on the screen.
    LOOP
    CLOSE #1
    KILL "LIST"

See Also    \i\p\aINKEY$\v@INKEY$\v\i\p    \i\p\aINPUT$\v@INPUT$\v\i\p    \i\p\aOPEN Statement File Modes\v@APPEND\v\i\p
.context LIST
.context @LIST
.context KEY
.context @KEY
:nKEY Statement (Assignment)
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Assigns string values to function keys and, optionally, displays key values.

\bKEY key%, stringexpression$\p
\bKEY LIST\p
\bKEY ON\p
\bKEY OFF\p

    ş \bkey%\p                 The number of a function key. Use 1 through 10 for
                           function keys F1 through F10. Use 30 and 31 for
                           function keys F11 and F12 on extended keyboards.
    ş \bstringexpression$\p    A string of up to 15 characters that is returned
                           when the function key is pressed.
    ş \bLIST\p                 Displays the assignments for each key.
    ş \bON\p                   Turns on the function-key display line.
    ş \bOFF\p                  Turns off the function-key display line.

Example:
    KEY 4, "MENU" + CHR$ (13)
    KEY LIST
    KEY 4, ""
    KEY LIST

See Also    \i\p\aKEY, ON KEY (Event Trapping)\v@ketv\v\i\p
.context KILL
.context @KILL
:nKILL Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Deletes files from disk.

\bKILL filespec$\p

    ş \bfilespec$\p    Identifies the file or files to delete. It may include
                   a path and the DOS wildcard characters ? and *.

Example:
    INPUT "File to delete: "; f$
    KILL f$

See Also    \i\p\aFILES\v@FILES\v\i\p
.context LOCATE
.context @LOCATE
.context CSRLIN
.context @CSRLIN
.context POS
.context @POS
:nLOCATE Statement, CSRLIN, POS Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
LOCATE moves the cursor to a specified position on the screen.
CSRLIN returns the current row position of the cursor.
POS returns the current column position of the cursor.

\bLOCATE  [row%] [,[column%] [,[cursor%] [,start% [,stop%]]]]\p
\bCSRLIN\p
\bPOS(expression)\p

    ş \brow%\p and \bcolumn%\p    The number of the row and column to which the
                          cursor moves.
    ş \bcursor%\p             Specifies whether the cursor is visible:
                            0 = invisible, 1 = visible
    ş \bstart%\p and \bstop%\p    Integer expressions in the range 0 through 31
                          that specify the first and last cursor scan lines.
                          You can change the cursor size by changing the
                          cursor scan lines.
    ş \bexpression\b          Any expression.

Example:
    CLS
    LOCATE 5, 5
    MyRow% = CSRLIN
    MyCol% = POS(0)
    PRINT "Position 1 (Press any key)"
    DO
    LOOP WHILE INKEY$ = ""
    LOCATE (MyRow% + 2), (MyCol% + 2)
    PRINT "Position 2"
.context LPOS
.context @LPOS
:nLPOS Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the number of characters sent to a printer since the last carriage
return was sent.

\bLPOS(n%)\p

    ş \bn%\p    Indicates one of the printer ports:
              0 = LPT1, 1 = LPT1, 2 = LPT2, 3 = LPT3
Example:
    'This example requires a printer.
    LPRINT
    FOR i% = 1 TO 20
        LPRINT i%;
        IF LPOS(1) >= 10 THEN LPRINT     'Begin a new line.
    NEXT i%
.context .opcom
.context @opcom
:nOPEN COM Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Opens and initializes a communications channel for input or output (I/O).
The OPEN COM statement must be executed before a device can be used for
communication using an RS232 interface.

\bOPEN "COMn: optlist1 optlist2" [FOR mode] AS [#]filenum% [LEN=reclen%]\p

    ş \bn\p           The communications port to open (1 = COM1, 2 = COM2).
    ş \boptlist1\p    The most-often-used communications parameters:
                    \b[baud] [,[parity] [,[data] [,[stop]]]]\p
                  baud is the baud rate of the device to be opened:
                    75, 110, 150, 300, 600, 1200, 2400, 4800, 9600
                  parity is the method of parity checking:
                    N (none)     E (even)    O (odd)
                    S (space)    M (mark)    PE (enable error checking)
                  data is the number of data bits per byte:
                    5, 6, 7, 8
                  stop is the number of stop bits:
                    1, 1.5, 2
                  Defaults: 300 baud, even parity, 7 data bits, 1 stop bit.
    ş \boptlist2\p    A list of less-often-used parameters, separated by commas:

                  Option    Description
                  ÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                  ASC       Opens the device in ASCII mode.
                  BIN       Opens the device in binary mode.
                  CD[m]     Sets the timeout period (in milliseconds) on the
                            Data Carrier Detect (DCD) line.
                  CS[m]     Sets the timeout period (in milliseconds) on the
                            Clear to Send (CTS) line.
                  DS[m]     Sets the timeout period (in milliseconds) on the
                            Data Set Ready (DS) line.
                  LF        Sends a line-feed character after a carriage
                            return.
                  OP[m]     Specifies how long (in milliseconds) OPEN COM
                            waits for all communications lines to become open.
                  RB[n]     Sets the size (in bytes) of the receive buffer.
                  RS        Suppresses detection of Request to Send (RTS).
                  TB[n]     Sets the size (in bytes) of the transmit buffer.

    ş \bmode\p        INPUT, OUTPUT, or RANDOM (the default).
                  See \i\p\aOPEN Statement File Modes\v@APPEND\v\i\p.
    ş \bfilenum%\p    A number in the range 1 through 255 that identifies the
                  communications channel as long as it is open.
    ş \breclen%\p     Random-access-mode buffer size (default is 128 bytes).

Example:
    'Use this example for trouble shooting serial communications problems.
    'Slow baud, hardware handshaking is ignored and buffers are enlarged.
    OPEN "COM1:300,N,8,1,CD0,CS0,DS0,OP0,RS,TB2048,RB2048" FOR RANDOM AS #1

See Also    \i\p\aOPEN\v@OPEN\v\i\p
.context .penf
.context @penf
:nPEN Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the status of the light pen.

\bPEN(n%)\p

    ş \bn%\p    Specifies the information to be returned about light pen status:

            n%    Returns
            ÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
            0     Whether pen was used since last call (-1 if yes, 0 if no)
            1     The x screen coordinate of the last pen press
            2     The y screen coordinate of the last pen press
            3     The current pen switch status (-1 if down, 0 if up)
            4     The x screen coordinate where the pen last left the screen
            5     The y screen coordinate where the pen last left the screen
            6     The character row of the last pen press
            7     The character column of the last pen press
            8     The character row where the pen last left the screen
            9     The character column where the pen last left the screen

Example:
    DO
      P = PEN(3)
      LOCATE 1, 1: PRINT "Pen is ";
      IF P THEN PRINT "down" ELSE PRINT "up  "
      PRINT "X ="; PEN(4), " Y ="; PEN(5); "  "
    LOOP

See Also    \i\p\aPEN, ON PEN Statements\v@PEN\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.context PLAY
.context @PLAY
:nPLAY Statement (Music)
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Plays musical notes.

\bPLAY commandstring$\p

    ş \bcommandstring$\p    A string expression that contains one or more of
                        the following PLAY commands:

      Octave and tone commands:
        O\boctave\p    Sets the current octave (0 - 6).
        < or >     Moves up or down one octave.
        A - G      Plays the specified note in the current octave.
        N\bnote\p      Plays a specified note (0 - 84) in the seven-octave
                   range (0 is a rest).

      Duration and tempo commands:
        L\blength\p    Sets the length of each note (1 - 64). L1 is whole note,
                   L2 is a half note, etc.
        ML         Sets music legato.
        MN         Sets music normal.
        MS         Sets music staccato.
        P\bpause\p     Specifies a pause (1 - 64). P1 is a whole-note pause,
                   P2 is a half-note pause, etc.
        T\btempo\p     Sets the tempo in quarter notes per minute (32 - 255).

      Mode commands:
        MF          Plays music in foreground.
        MB          Plays music in background.

      Suffix commands:
        # or +      Turns preceding note into a sharp.
        -           Turns preceding note into a flat.
        .           Plays the preceding note 3/2 as long as specified.

    ş To execute a PLAY command substring from a PLAY command string,
      use the "X" command:

      PLAY "X"+ VARPTR$(commandstring$)

Example:
    'Play scale in 7 different octaves
    scale$ = "CDEFGAB"
    PLAY "L16"
    FOR i% = 0 TO 6
        PLAY "O" + STR$(i%)
        PLAY "X" + VARPTR$(scale$)
    NEXT i%

See Also    \i\p\aBEEP\v@BEEP\v\i\p     \i\p\aPLAY Function\v@PLAYF\v\i\p    \i\p\aPLAY, ON PLAY (Event Trapping)\v@playev\v\i\p
            \i\p\aSOUND\v@SOUND\v\i\p    \i\p\aVARPTR$\v@VARPTR$\v\i\p    \i\p\aDifferences from BASICA\v@basica.diffs\v\i\p
.context PMAP
.context @PMAP
:nPMAP Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the window coordinate equivalent to a viewport coordinate, as defined
by the WINDOW statement, or vice versa.

\bPMAP (startcoordinate#, n%)\p

    ş \bstartcoordinate#\p    A window or viewport coordinate.
    ş \bn%\p                  A value indicating which coordinate is returned:

                          startcoordinate#        n%   Returns
                          ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ   ÍÍ   ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                          Window x coordinate     0    Viewport x coordinate
                          Window y coordinate     1    Viewport y coordinate
                          Viewport x coordinate   2    Window x coordinate
                          Viewport y coordinate   3    Window y coordinate

Example:
    'This example requires a graphics adapter that supports screen mode 1.
    SCREEN 1
    WINDOW SCREEN (0, 0)-(100, 100)
    PRINT "Logical x=50, physical x="; PMAP(50, 0)
    PRINT "Logical y=50, physical y="; PMAP(50, 1)

See Also    \i\p\aPOINT\v@POINT\v\i\p    \i\p\aVIEW\v@VIEW\v\i\p    \i\p\aWINDOW\v@WINDOW\v\i\p
.context POINT
.context @POINT
:nPOINT Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the current graphics cursor coordinates or the color attribute of a
specified pixel.

\bPOINT {(n%) | (x%,y%)}\p

    ş \b(n%)\p       Indicates the type of coordinate to return:

                 n%    Returns
                 ÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                 0     The current viewport x coordinate
                 1     The current viewport y coordinate
                 2     The current window x coordinate
                 3     The current window y coordinate

    ş \b(x%,y%)\p    The coordinates of the pixel that POINT checks for color.
                     If the coordinates are outside the current viewport,
                     POINT returns -1.

Example:
    'This example requires a color graphics adapter.
    SCREEN 1
    LINE (0, 0)-(100, 100), 2
    LOCATE 14, 1
    FOR y% = 1 TO 10
        FOR x% = 1 TO 10
            PRINT POINT(x%, y%);
        NEXT x%
        PRINT
    NEXT y%

See Also    \i\p\aCOLOR\v@COLOR\v\i\p    \i\p\aPMAP\v@PMAP\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aVIEW\v@VIEW\v\i\p    \i\p\aWINDOW\v@WINDOW\v\i\p
            \i\p\aColor Attributes and Values\v@color.table\v\i\p
.context PRESET
.context @PRESET
.context PSET
.context @PSET
:nPRESET, PSET Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Draw a specified point on the screen.

\bPRESET [STEP] (x!,y!) [,color%]\p
\bPSET [STEP] (x!,y!) [,color%]\p

    ş \bSTEP\p       Specifies that the x! and y! are expressed relative
                 to the current graphics cursor location.
    ş \b(x!,y!)\p    The screen coordinates of the pixel to be set.
    ş \bcolor%\p     A color attribute that sets the pixel color. If color% is
                 omitted, PRESET uses the current background and PSET uses
                 the current foreground color.

    ş Available color attributes depend on your graphics adapter and screen
      mode. Coordinate values depend on the graphics adapter, screen mode,
      and most recent VIEW and WINDOW statements.

Example:
    'This example requires a color graphics adapter.
    SCREEN 1
    FOR i% = 0 TO 320
        PSET (i%, 100)
        FOR delay% = 1 TO 100: NEXT delay%
        PRESET (i%, 100)
    NEXT i%

See Also    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aVIEW\v@VIEW\v\i\p    \i\p\aWINDOW\v@WINDOW\v\i\p
            \i\p\aColor Attributes and Values\v@color.table\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.context PRINT
.context @PRINT
.context LPRINT
.context @LPRINT
:nPRINT, LPRINT Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
PRINT writes data to the screen or to a file.
LPRINT prints data on the printer LPT1.

\bPRINT [#filenumber%,] [expressionlist] [{; | ,}]\p
\bLPRINT [expressionlist] [{; | ,}]\p

    ş \bfilenumber%\p       The number of an open file. If you don't specify a
                        file number, PRINT writes to the screen.
    ş \bexpressionlist\p    A list of one or more numeric or string expressions
                        to print.
    ş \b{; | ,}\p           Determines where the next output begins:
                          ; means print immediately after the last value.
                          , means print at the start of the next print zone.
                            Print zones are 14 characters wide.

Example:
    OPEN "TEST.DAT" FOR OUTPUT AS #1
    PRINT #1, USING "##.###  "; 12.12345
    CLOSE
    OPEN "TEST.DAT" FOR INPUT AS #1
    INPUT #1, a$
    PRINT a$
    LPRINT "This is a line"; 1
    LPRINT "This is a line",
    LPRINT 2

See Also    \i\p\aPRINT USING, LPRINT USING\v@zpu\v\i\p    \i\p\aWIDTH\v@WIDTH\v\i\p    \i\p\aWRITE\v@WRITE\v\i\p
.context .zpu
.context @zpu
.context .lprintu
.context @lprintu
:nPRINT USING, LPRINT USING Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
PRINT USING writes formatted output to the screen or to a file.
LPRINT USING prints formatted output on the printer LPT1.

\bPRINT [#filenumber%,] USING formatstring$; expressionlist [{; | ,}]\p
\bLPRINT USING formatstring$; expressionlist [{; | ,}]\p

    ş \bfilenumber%\p       The number of an open sequential file.
    ş \bformatstring$;\p    A string expression containing one or more
                        \i\p\aformat specifiers\v@forspec\v\i\p.
    ş \bexpressionlist\p    A list of one or more numeric or string expressions
                        to print, separated by commas, semicolons, spaces,
                        or tabs.
    ş \b{; | ,}\p           Determines where the next output begins:
                          ; means print immediately after the last value.
                          , means print at the start of the next print zone.
                            Print zones are 14 characters wide.
Example:
    a = 123.4567
    PRINT USING "###.##"; a
    LPRINT USING "+###.####"; a
    a$ = "ABCDEFG"
    PRINT USING "!"; a$
    LPRINT USING "\\ \\"; a$

See Also    \i\p\aPRINT, LPRINT\v@PRINT\v\i\p    \i\p\aWIDTH\v@WIDTH\v\i\p
.context @forspec
:nFormat Specifiers
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                     \bCharacters that format a numeric expression\p
 \b#\p    Digit position.                    º \b-\p     Placed after digit, prints
 \b.\p    Decimal point position.            º       trailing sign for negative
 \b,\p    Placed left of the decimal point,  º       numbers.
      prints a comma every third digit.  º \b$$\p    Prints leading $.
 \b+\p    Position of number sign.           º \b**\p    Fills leading spaces with *.
\b^^^^\p  Prints in exponential format.      º \b**$\p   Combines ** and $$.

                     \bCharacters used to format a string expression\p
 \b&\p    Prints entire string.              º \b\\ \\\p   Prints first n characters,
 \b!\p    Prints only the first character    º       where n is the number of
      of the string.                     º       blanks between slashes + 2.

                     \bCharacters used to print literal characters\p
 \b_\p    Prints the following formatting    º       Any character not in this
      character as a literal.            º       table is printed as a
                                         º       literal.
.context SOUND
.context @SOUND
:nSOUND Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Generates a sound through your computer's speaker.

\bSOUND frequency, duration\p

    ş \bfrequency\p    The frequency of the sound in hertz; a value in the range
                   37 through 32,767.
    ş \bduration\p     The number of system clock ticks the sound lasts; a value
                   in the range 0 through 65,535. There are 18.2 clock ticks
                   per second.

Example:
    FOR i% = 440 TO 1000 STEP 5
    SOUND i%, i% / 1000
    NEXT i%

See Also    \i\p\aPLAY\v@PLAY\v\i\p
.context SPC
.context @SPC
:nSPC Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Skips a specified number of spaces in a PRINT or LPRINT statement.

\bSPC(n%)\p

    ş \bn%\p    The number of spaces to skip; a value in the range
            0 through 32,767.

Example:
    PRINT "Text1"; SPC(10); "Text2"

See Also    \i\p\aPRINT, LPRINT\v@PRINT\v\i\p    \i\p\aPRINT USING, LPRINT USING\v@zpu\v\i\p
            \i\p\aSPACE$\v@SPACE$\v\i\p           \i\p\aTAB\v@TAB\v\i\p
.context STICK
.context @STICK
:nSTICK Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the coordinates of a joystick.

\bSTICK(n%)\p

    ş \bn%\p    Indicates the coordinate returned:

            n%    Returns
            ÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
            0     x coordinate of joystick A
            1     y coordinate of joystick A
            2     x coordinate of joystick B
            3     y coordinate of joystick B

    ş You must call STICK(0) before STICK(1), STICK (2), or STICK(3).
      STICK(0) records the current coordinates.

Example:
    Temp% = STICK(0)
    PRINT STICK(2), STICK(3)

See Also    \i\p\aSTRIG Function\v@strigf\v\i\p    \i\p\aSTRIG, ON STRIG Statements\v@STRIG\v\i\p
.context TAB
.context @TAB
:nTAB Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Moves the text cursor to a specified print position.

\bTAB(column%)\p

    ş \bcolumn%\p    The column number of the new print position.

Example:
    PRINT TAB(25); "Text"

See Also    \i\p\aPRINT, LPRINT\v@PRINT\v\i\p    \i\p\aPRINT USING, LPRINT USING\v@zpu\v\i\p
            \i\p\aSPC\v@SPC\v\i\p    \i\p\aSPACE$\v@SPACE$\v\i\p
.context .vupri
.context @vupri
:nVIEW PRINT Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Sets the boundaries of the screen text viewport.

\bVIEW PRINT [toprow% TO bottomrow%]\p

    ş \btoprow%\p       The number of the top row of the text viewport.
    ş \bbottomrow%\p    The number of the bottom row of the text viewport.

    ş If you omit the toprow% and bottomrow% arguments, VIEW PRINT sets the
      entire screen as the text viewport.
    ş Ranges for toprow% and bottomrow% depend on the screen mode.

Example:
    VIEW PRINT 10 TO 15
    FOR i% = 1 TO 100      'Output will scroll.
        PRINT i%
    NEXT i%

See Also    \i\p\aCLS\v@CLS\v\i\p    \i\p\aLOCATE\v@LOCATE\v\i\p    \i\p\aPRINT, LPRINT\v@PRINT\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aWIDTH\v@WIDTH\v\i\p
            \i\p\aScreen Modes\v@screen.modes\v\i\p
.context WAIT
.context @WAIT
:nWAIT Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Suspends program execution until a specified bit pattern is input from an
input port.

\bWAIT portnumber%, AND-expression% [,XOR-expression%]\p

    ş \bportnumber%\p        The number of the input port.
    ş \bAND-expression%\p    An integer expression that WAIT combines with the
                         bit pattern value using an AND operator. When the
                         result is nonzero, WAIT stops monitoring the port.
    ş \bXOR-expression%\p    Can be used to turn line bits on and off in the bit
                         pattern before the AND operation is applied.

Example:
    'Reads the interrupt controller port address &H20.
    'Press any key to continue.
    WAIT &H20, 1

See Also    \i\p\aINP, OUT\v@INP\v\i\p    \i\p\aBoolean Operators\v@AND\v\i\p
.context WIDTH
.context @WIDTH
:nWIDTH Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Assign an output-line width to a device (such as a printer) or file, or
change the number of screen-display columns and rows.

\bWIDTH [columns%] [,rows%]\p
\bWIDTH {#filenumber% | device$}, columns%\p
\bWIDTH LPRINT columns%\p

    ş \bcolumns%\p        The desired width in columns. Screen display width
                      must be 40 or 80 columns.
    ş \brows%\p           The desired screen-display height in rows. The value
                      can be 25, 30, 43, 50, or 60, depending on your
                      display adapter and screen mode.
    ş \b#filenumber%\p    The number of an open file or device.
    ş \bdevice$\p         The name of a device:
                        SCRN:, COM1:, COM2:, LPT1:, LPT2:, LPT3:

Example:
    OPEN "LPT1:" FOR OUTPUT AS #1
    WIDTH #1, 132

See Also    \i\p\aPRINT, LPRINT\v@LPRINT\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aVIEW PRINT\v@vupri\v\i\p
.context WINDOW
.context @WINDOW
:nWINDOW Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Defines logical dimensions for the current graphics viewport. Use the WINDOW
statement to define your own viewport coordinate system.

\bWINDOW [[SCREEN] (x1!,y1!)-(x2!,y2!)]\p

    ş \bSCREEN\p       Inverts the normal Cartesian direction of the y screen
                   coordinates so that y values increase from the top of the
                   screen to the bottom.
    ş \b(x1!,y1!)\p    Logical coordinates that map to the upper-left screen
                   coordinates of the viewport.
    ş \b(x2!,y2!)\p    Logical coordinates that map to the lower-right screen
                   coordinates of the viewport.

    ş WINDOW with no arguments disables the logical coordinate system.
    ş Use the VIEW statement to change the size of the viewport.

Example:
    'This example requires a color graphics adapter.
    SCREEN 1
    FOR i% = 1 TO 10 STEP 2
        WINDOW (-160 / i%, -100 / i%)-(160 / i%, 100 / i%)
        CIRCLE (0, 0), 10
    NEXT i%

See Also    \i\p\aCLS\v@CLS\v\i\p    \i\p\aPMAP\v@PMAP\v\i\p    \i\p\aPOINT\v@POINT\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aVIEW\v@VIEW\v\i\p    \i\p\aWIDTH\v@WIDTH\v\i\p
.comment *****************************************************************
.comment * One Keyword screen in this family.
.comment *****************************************************************
.context USING
.context @USING
:nUSING Keyword
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Specifies formatting for PRINT USING and LPRINT USING statements and the
palette assignments for the PALETTE USING statement.

See Also    \i\p\aPALETTE, PALETTE USING\v@PALETTE\v\i\p    \i\p\aPRINT USING, LPRINT USING\v@zpu\v\i\p
.comment ******************************************************************
.comment *  Graphics Family - QBasic                                      *
.comment ******************************************************************
.comment * 1/10/91 Cleaned up comments.
.comment *   -- JeffWe
.comment ******************************************************************
.context CIRCLE
.context @CIRCLE
:nCIRCLE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Draws a circle or ellipse on the screen.

\bCIRCLE [STEP] (x!,y!),radius![,[color%] [,[start!] [,[end!] [,aspect!]]]]\p

    ş \bSTEP\p       Specifies that coordinates are relative to the current
                 graphics cursor position.
    ş \b(x!,y!)\p    The coordinates for the center of the circle or ellipse.
    ş \bradius!\p    The radius of the circle or ellipse in the units of the
                 current coordinate system, determined by the most recent
                 SCREEN, VIEW, and WINDOW statements.
    ş \bcolor%\p     A color attribute that sets the circle's color. The
                 available color attributes depend on your graphics adapter
                 and the screen mode set by the most recent SCREEN statement.
    ş \bstart!\p     The starting angle for the arc, in radians.
    ş \bend!\p       The ending angle for the arc, in radians.
    ş \baspect!\p    The ratio of the length of the y axis to the length of the
                 x axis, used to draw ellipses.

    ş To convert from degrees to radians, multiply degrees by (PI / 180).

Example:
    'This example requires a color graphics adapter.
    SCREEN 2
    CIRCLE (320, 100), 200
    CIRCLE STEP (0,0), 100

See Also    \i\p\aCOLOR\v@COLOR\v\i\p    \i\p\aDRAW\v@DRAW\v\i\p    \i\p\aLINE\v@LINE\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aVIEW\v@VIEW\v\i\p    \i\p\aWINDOW\v@WINDOW\v\i\p
            \i\p\aColor Attributes and Values\v@color.table\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.context COLOR
.context @COLOR
:nCOLOR Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Sets the screen display colors.

\bCOLOR [foreground%] [,[background%] [,border%]]\p    Screen mode 0 (text only)
\bCOLOR [background%] [,palette%]\p                    Screen mode 1
\bCOLOR [foreground%]\p                                Screen modes 4, 12, 13
\bCOLOR [foreground%] [,background&]\p                 Screen modes 7-10

    ş \bforeground%\p    A number that sets the foreground screen color. In
      \bforeground&\p    screen mode 0, foreground% is a color attribute that
                     sets the text color. In other screen modes, foreground%
                     a color attribute or 4-bit color value (screen mode 4
                     only) that sets the text and line-drawing color.
    ş \bbackground%\p    A number that sets the background screen color. In
      \bbackground&\p    screen mode 0, background% is a color attribute. In
                     screen mode 1, background% is a 4-bit color value. In
                     screen modes 7-10, background& is a color value.
    ş \bborder%\p        A color attribute that sets the screen border color.
    ş \bpalette%\p       A number (0 or 1) that specifies which of two sets
                     of color attributes to use:

                     palette%    Attribute 1    Attribute 2    Attribute 3
                     ÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍ
                     0           Green          Red            Brown
                     1           Cyan           Magenta        Bright white

    ş The available color attributes and values depend on your graphics
      adapter and the screen mode set by the most recent SCREEN statement.
    ş If your system is equipped with an EGA, VGA, or MCGA adapter, use the
      PALETTE statement to change the color assignments of color attributes.

Example:
    'This example requires a color graphics adapter.
    SCREEN 7
    FOR i% = 0 TO 15
        COLOR i%
        PRINT i%
    NEXT i%

See Also    \i\p\aDRAW\v@DRAW\v\i\p    \i\p\aPAINT\v@PAINT\v\i\p    \i\p\aPALETTE, PALETTE USING\v@PALETTE\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p
            \i\p\aColor Attributes and Values\v@color.table\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.context @color.table
:nColor Attributes and Values
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
             \bColor monitor                      Monochrome monitor\p
             ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
\bColor        Default          Displayed         Default       Displayed\p
\battribute    color value\p(a)\b   color             color value   color\p
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
\bSCREEN Modes 0, 7, 8, 9\p(b)\b, 12, and 13\p
0            0                Black             0(c)          Off
1            1                Blue                            Underlined(d)
2            2                Green             1(c)          On(d)
3            3                Cyan              1(c)          On(d)
4            4                Red               1(c)          On(d)
5            5                Magenta           1(c)          On(d)
6            6                Brown             1(c)          On(d)
7            7                White             1(c)          On(d)
8            8                Gray              0(c)          Off
9            9                Light Blue                      High-intensity
                                                              Underlined
10           10               Light green       2(c)          High-intensity
11           11               Light cyan        2(c)          High-intensity
12           12               Light red         2(c)          High-intensity
13           13               Light magenta     2(c)          High-intensity
14           14               Yellow            2(c)          High-intensity
15           15               High-intensity    0(c)          Off
                              white
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
\bSCREEN Modes 1 and 9\p(e)

0            0                Black             0             Off
1            11               Light cyan        2             High-intensity
2            13               Light magenta     2             High-intensity
3            15               High-intensity    0             Off white
                              white
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
\bSCREEN Modes 2 and 11\p
0            0                Black             0             Off
1            15               High-intensity    0             Off white
                              white
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  (a)  EGA color numbers. VGA and MCGA use display-color values that produce
       visually equivalent colors.
  (b)  For VGA or EGA with video memory > 64K.
  (c)  Only for mode 0.
  (d)  Off when used for background.
  (e)  EGA with video memory <= 64K.

See Also    \i\p\aCOLOR\v@COLOR\v\i\p    \i\p\aPALETTE, PALETTE USING\v@PALETTE\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p
            \i\p\aScreen Modes\v@screen.modes\v\i\p
.context DRAW
.context @DRAW
:nDRAW Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Draws an object.

\bDRAW commandstring$\p

    ş \bcommandstring$\p    A string expression that contains one or more of
                        the following DRAW commands.

      Line-drawing and cursor-movement commands:
        D[n%]            Moves cursor down n% units.
        E[n%]            Moves cursor up and right n% units.
        F[n%]            Moves cursor down and right n% units.
        G[n%]            Moves cursor down and left n% units.
        H[n%]            Moves cursor up and left n% units.
        L[n%]            Moves cursor left n% units.
        M[{+|-}]x%,y%    Moves cursor to point x%,y%. If x% is preceded
                         by + or -, moves relative to the current point.
        R[n%]            Moves cursor right n% units.
        U[n%]            Moves cursor up n% units.
        [B]              Optional prefix that moves cursor without drawing.
        [N]              Optional prefix that draws and returns cursor to
                         its original position.

      Color, rotation, and scale commands:
        An%              Rotates an object n% * 90 degrees (n% can be 0, 1,
                         2, or 3).
        Cn%              Sets the drawing color (n% is a color attribute).
        Pn1%,n2%         Sets the paint fill and border colors of an object
                         (n1% is the fill-color attribute, n2% is the
                         border-color attribute).
        Sn%              Determines the drawing scale by setting the length
                         of a unit of cursor movement. The default n% is 4,
                         which is equivalent to 1 pixel.
        TAn%             Turns an angle n% degrees (-360 through 360).

    ş If you omit n% from line-drawing and cursor-movement commands, the
      cursor moves 1 unit.
    ş To execute a DRAW command substring from a DRAW command string, use
      the "X" command:

      DRAW "X"+ VARPTR$(commandstring$)

Example:
    'This example requires a color graphics adapter.
    SCREEN 1
    Triangle$ = "F60 L120 E60"
    DRAW "C2 X" + VARPTR$(Triangle$)
    DRAW "BD30 P1,2 C3 M-30,-30"

See Also    \i\p\aPALETTE, PALETTE USING\v@PALETTE\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aVARPTR$\v@VARPTR$\v\i\p
            \i\p\aColor Attributes and Values\v@color.table\v\i\p    \i\p\aDifferences from BASICA\v@basica.diffs\v\i\p
.context .ggx
.context @ggx
.context .pgfx
.context @pgfx
:nGET, PUT Statements (Graphics)
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
GET captures a graphics screen image. PUT displays an image captured by GET.

\bGET [STEP](x1!,y1!)-[STEP](x2!,y2!), arrayname[(index%)]\p
\bPUT [STEP] (x1!,y1!), arrayname[(index%)] [,actionverb]\p

    ş \bSTEP\p          Specifies that coordinates are relative to the current
                    graphics cursor position.
    ş \b(x1!,y1!)\p     The upper-left coordinates of the image captured by GET
                    or of the screen location where PUT displays the image.
    ş \b(x2!,y2!)\p     The lower-right coordinates of the captured image.
    ş \barrayname\p     The name of the array where the image is stored.
                    See \i\p\aScreen Image Arrays and Compatibility\v@ggx.arrays\v\i\p to determine
                    the required size of the array.
    ş \bindex%\p        The array index at which storage of the image begins.
    ş \bactionverb\p    A keyword indicating how the image is displayed:

                    Keyword    Action
                    ÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                    AND        Merges stored image with an existing image.
                    OR         Superimposes stored image on existing image.
                    PSET       Draws stored image, erasing existing image.
                    PRESET     Draws stored image in reverse colors, erasing
                               existing image.
                    XOR        Draws a stored image or erases a previously
                               drawn image while preserving the background,
                               producing animation effects.

    ş A PUT statement should always be executed in the same screen mode as
      the GET statement used to capture the image, or a compatible mode.
      See \i\p\aScreen Image Arrays and Compatibility\v@ggx.arrays\v\i\p.

Example:
    'This example requires a color graphics adapter.
    SCREEN 1
    DIM Box%(1 TO 200)
    x1% = 0: x2% = 10: y1% = 0: y2% = 10
    LINE (x1%, y1%)-(x2%, y2%), 2, BF
    GET (x1%, y1%)-(x2%, y2%), Box%
    DO
        PUT (x1%, y1%), Box%, XOR
        x1% = RND * 300
        y1% = RND * 180
        PUT (x1%, y1%), Box%
    LOOP WHILE INKEY$ = ""

See Also    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.context @ggx.arrays
:nScreen Image Arrays and Compatibility
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Use bits-per-pixel-per-plane and planes values to determine the required size
of the array that holds a graphics screen image. Bits-per-pixel-per-plane and
planes values, along with the horizontal resolution, also determine which
screen modes are compatibile:

                                                                 Horizontal
                                    Bits-per-pixel-              resolution
    Screen mode                     per-plane          Planes    (in pixels)
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍ
    1                               2                  1         320
    2, 4, 11                        1                  1         640
    3                               1                  1         720
    7                               1                  4         320
    8, 9(> 64K video memory), 12    1                  4         640
    9(64K video memory), 10         1                  2         640
    13                              8                  1         320

The following formula gives the required size, in bytes, of an array used
to hold a captured image:

size% = 4 + INT(((PMAP (x2!, 0) - PMAP (x1!, 0) + 1) *
        (bits-per-pixel-per-plane%) + 7) / 8) * planes% *
        (PMAP (y2!, 1) - PMAP (y1!, 1) + 1)

GET and PUT operations are compatible in screen modes with the same
horizontal resolution and bits-per-pixel-per-plane and planes values. For
example, screen modes 2, 4, and 11 are compatible, and screen modes 8 and 12
are compatible.

See Also    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.context LINE
.context @LINE
:nLINE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Draws a line or rectangle on the screen.

\bLINE [[STEP](x1!,y1!)]-[STEP](x2!,y2!) [,[color%] [,[B | BF] [,style%]]]\p

    ş \bSTEP\p          Specifies that coordinates are relative to the current
                    graphics cursor position.
    ş \b(x1!,y1!)\p,    The screen coordinates of the start of the line and of
      \b(x2!,y2!)\p     the end of the line.
    ş \bcolor%\p        A color attribute that sets the color of the line or
                    rectangle. The available color attributes depend on your
                    graphics adapter and the screen mode set by the most
                    recent SCREEN statement.
    ş \bB\p             Draws a rectangle instead of a line.
    ş \bBF\p            Draws a filled box.
    ş \bstyle%\p        A 16-bit value whose bits set whether or not pixels are
                    drawn. Use to draw dashed or dotted lines.

Example:
    'This example requires a color graphics adapter.
    SCREEN 1
    LINE (110, 70)-(190, 120), , B
    LINE (0, 0)-(320, 200), 3, , &HFF00

See Also    \i\p\aCIRCLE\v@CIRCLE\v\i\p    \i\p\aINPUT, LINE INPUT\v@INPUT\v\i\p    \i\p\aPRESET, PSET\v@PSET\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p
            \i\p\aColor Attributes and Values\v@color.table\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.context PAINT
.context @PAINT
:nPAINT Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Fills a graphics area with a specified color or pattern.

\bPAINT [STEP] (x!,y!)[,[{color% | tile$}] [,[bordercolor%] [,background$]]]\p

    ş \bSTEP\p            Specifies that coordinates are relative to the current
                      graphics cursor position.
    ş \b(x!,y!)\p         The screen coordinates where painting begins.
    ş \bcolor%\p          A color attribute that sets the fill color.
    ş \btile$\p           A fill pattern that is 8 bits wide and up to 64 bytes
                      long, defined as follows:

                        tile$ = CHR$(arg1) + CHR$(arg2) + ... + CHR$(argn%)

                      The arguments to CHR$ are numbers between 0 and 255.
                      Each CHR$(argn%) defines a 1-byte, 8-pixel slice of
                      the pattern based on the binary form of the number.
    ş \bbordercolor%\p    A color attribute that specifies the color of the
                      filled area's border. PAINT stops filling an area when
                      it encounters a border of the specified color.
    ş \bbackground$\p     A 1-byte, 8-pixel background tile slice. Specifying a
                      background tile slice allows you to paint over an area
                      that has already been painted.

    ş The available color attributes depend on your graphics adapter and the
      screen mode set by the most recent SCREEN statement.

Example:
    'This example requires a color graphics adapter.
    SCREEN 1
    CIRCLE (106, 100), 75, 1
    LINE (138, 35)-(288, 165), 1, B
    PAINT (160, 100), 2, 1

See Also    \i\p\aASC, CHR$\v@CHR$\v\i\p    \i\p\aCIRCLE\v@CIRCLE\v\i\p    \i\p\aDRAW\v@DRAW\v\i\p    \i\p\aLINE\v@LINE\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p
            \i\p\aColor Attributes and Values\v@color.table\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.context PALETTE
.context @PALETTE
:nPALETTE, PALETTE USING Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Change the color assignments of color attributes in the current screen mode.
PALETTE and PALETTE USING work only on systems equipped with EGA, VGA, or
MCGA adapters.

\bPALETTE [attribute%,color&]\p
\bPALETTE USING arrayname#[(index%)]\p

    ş \battribute%\p    The color attribute to change.
    ş \bcolor&\p        A color value to assign to an attribute.
    ş \barrayname#\p    An array of color values to assign to the current screen
                    mode's set of attributes. The array must be large enough
                    to assign colors to all the attributes.
    ş \bindex%\p        The index of the first array element to assign to an
                    attribute.

    ş The available color attributes and values depend on your graphics
      adapter and the screen mode set by the most recent SCREEN statement.

Example:
    'This example requires a color graphics adapter.
    PALETTE 0, 1
    SCREEN 1
    FOR i% = 0 TO 3: a%(i%) = i%: NEXT i%
    LINE (138, 35)-(288, 165), 3, BF
    LINE (20, 10)-(160, 100), 2, BF
    DO
        FOR i% = 0 TO 3
            a%(i%) = (a%(i%) + 1) MOD 16
        NEXT i%
        PALETTE USING a%(0)
    LOOP WHILE INKEY$ = ""

See Also    \i\p\aCOLOR\v@COLOR\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p
            \i\p\aColor Attributes and Values\v@color.table\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.context PCOPY
.context @PCOPY
:nPCOPY Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Copies one video memory page to another.

\bPCOPY sourcepage%,destinationpage%\p

    ş \bsourcepage%\p         The number of a video memory page to copy.
    ş \bdestinationpage%\p    The number of the video memory page to copy to.

    ş The value that identifies the video page is determined by the size
      of video memory and the current screen mode.

Example:
    PCOPY 1, 3

See Also    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.context SCREEN
.context @SCREEN
:nSCREEN Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Sets the screen mode and other characteristics of your screen.

\bSCREEN mode% [,[colorswitch%] [,[activepage%] [,visualpage%]]]\p

    ş \bmode%\p           Sets the screen mode. See \i\p\aScreen Modes\v@screen.modes\v\i\p.
    ş \bcolorswitch%\p    A value (0 or 1) that switches between color and
                      monocolor display (modes 0 and 1 only):

                      Mode    Value       Action
                      ÍÍÍÍ    ÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                      0       0           Disables color
                      0       Nonzero     Enables color
                      1       0           Enables color
                      1       Nonzero     Disables color

    ş \bactivepage%\p     The screen page that text or graphics output writes to.
    ş \bvisualpage%\p     The screen page that is currently displayed on your
                      screen.

Example:
    'This example requires a color graphics adapter.
    SCREEN 1        '320 x 200 graphics
    LINE (110, 70)-(190, 120), , B
    LINE (0, 0)-(320, 200), 3, , &HFF00

See Also    \i\p\aCIRCLE\v@CIRCLE\v\i\p    \i\p\aCOLOR\v@COLOR\v\i\p    \i\p\aDRAW\v@DRAW\v\i\p    \i\p\aLINE\v@LINE\v\i\p      \i\p\aPAINT\v@PAINT\v\i\p
            \i\p\aSCREEN Function\v@screenf\v\i\p      \i\p\aVIEW\v@VIEW\v\i\p    \i\p\aWINDOW\v@WINDOW\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.context @screen.modes
:nScreen Modes
  \i\p\aContents\vhelpTableId\v\i\p  \i\p\aIndex\vhelpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
The following table summarizes screen modes:

ÄÄÄÄÄÄÄÄÄÄMDPA, CGA, Hercules, Olivetti, EGA, VGA, or MCGA AdaptersÄÄÄÄÄÄÄÄÄÄÄ
SCREEN 0: Text mode only
    ş 40 x 25, 40 x 43, 40 x 50, 80 x 25, 80 x 43, or 80 x 50 text format,
      8 x 8 character box (8 x 14, 9 x 14, or 9 x 16 with EGA or VGA)
    ş 16 colors assigned to any of 16 attributes (with CGA or EGA)
    ş 64 colors assigned to any of 16 attributes (with EGA or VGA)
    ş Depending on the text resolution and adapter, 8 video memory pages
      (0-7), 4 pages (0-3), 2 pages (0-1), or 1 page (0)

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄCGA, EGA, VGA, or MCGA AdaptersÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
SCREEN 1: 320 x 200 graphics
    ş 40 x 25 text format, 8 x 8 character box
    ş 16 background colors and one of two sets of 3 foreground colors
      assigned using COLOR statement with CGA
    ş 16 colors assigned to 4 attributes with EGA or VGA
    ş 1 video memory page (0)
SCREEN 2: 640 x 200 graphics
    ş 80 x 25 text format, 8 x 8 character box
    ş 16 colors assigned to 2 attributes with EGA or VGA
    ş 1 video memory page (0)

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄHercules, Olivetti, or AT&T AdaptersÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
SCREEN 3: Hercules adapter required, monochrome monitor only
    ş 720 x 348 graphics
    ş 80 x 25 text format, 9 x 14 character box
    ş Usually 2 video memory pages (0-1); 1 page (0) if a second color
      display adapter is installed
    ş PALETTE statement not supported
    ş Invoke the Hercules driver MSHERC.COM before using screen mode 3
SCREEN 4:
    ş Supports Olivetti Personal Computers models M24, M240, M28, M280,
      M380, M380/C, and M380/T and AT&T Personal Computers 6300 series
    ş 640 x 400 graphics
    ş 80 x 25 text format, 8 x 16 character box
    ş 1 of 16 colors assigned as the foreground color (selected by the
      COLOR statement); background is fixed at black
    ş 1 video memory page (0)
    ş PALETTE statement not supported

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄEGA or VGA AdaptersÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
SCREEN 7: 320 x 200 graphics
    ş 40 x 25 text format, 8 x 8 character box
    ş Assignment of 16 colors to any of 16 attributes
    ş If 64K EGA adapter memory, 2 video memory pages (0-1); otherwise,
      8 pages (0-7)
SCREEN 8: 640 x 200 graphics
    ş 80 x 25 text format, 8 x 8 character box
    ş Assignment of 16 colors to any of 16 attributes
    ş If 64K EGA adapter memory, 1 video memory page (0); otherwise,
      4 pages (0-3)
SCREEN 9: 640 x 350 graphics
    ş 80 x 25 or 80 x 43 text format, 8 x 14 or 8 x 8 character box
    ş 16 colors assigned to 4 attributes (64K adapter memory), or
      64 colors assigned to 16 attributes (more than 64K adapter memory)
    ş If 64K EGA adapter memory, 1 video memory page (0); otherwise,
      2 pages (0-1)

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄEGA or VGA Adapters, Monochrome Monitor OnlyÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
SCREEN 10: 640 x 350 graphics, monochrome monitor only
    ş 80 x 25 or 80 x 43 text format, 8 x 14 or 8 x 8 character box
    ş Up to 9 pseudocolors assigned to 4 attributes
    ş 2 video memory pages (0-1), 256K adapter memory required

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄVGA or MCGA AdaptersÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Screen 11 (VGA or MCGA)
    ş 640 x 480 graphics
    ş 80 x 30 or 80 x 60 text format, 8 x 16 or 8 x 8 character box
    ş Assignment of up to 256K colors to 2 attributes
    ş 1 video memory page (0)
Screen 12 (VGA)
    ş 640 x 480 graphics
    ş 80 x 30 or 80 x 60 text format, 8 x 16 or 8 x 8 character box
    ş Assignment of up to 256K colors to 16 attributes
    ş 1 video memory page (0)
Screen 13 (VGA or MCGA)
    ş 320 x 200 graphics
    ş 40 x 25 text format, 8 x 8 character box
    ş Assignment of up to 256K colors to 256 attributes
    ş 1 video memory page (0)

See Also    \i\p\aSCREEN Statement\v@SCREEN\v\i\p
.context @screenf
:nSCREEN Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the ASCII value or color attribute of a character at a specified
screen location.

\bSCREEN (row%,column% [,colorflag%])\p

    ş \brow%\p          The row coordinate of a character.
    ş \bcolumn%\p       The column coordinate of a character.
    ş \bcolorflag%\p    A value (0 or 1) that specifies what is returned.

                    Value             Returns
                    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                    0 (or omitted)    The character's ASCII code.
                    1                 The character's color attribute.

Example:
    CLS
    PRINT "Hello"
    PRINT "The ASCII value of character at 1,1 is"; SCREEN(1, 1)

See Also    \i\p\aPOINT\v@POINT\v\i\p    \i\p\aSCREEN Statement\v@SCREEN\v\i\p
            \i\p\aASCII Character Codes\v@ac\v\i\p    \i\p\aColor Attributes and Values\v@color.table\v\i\p
.context VIEW
.context @VIEW
:nVIEW Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Defines the size and location of a viewport where graphics can be displayed
on the screen.

\bVIEW [[SCREEN] (x1!,y1!)-(x2!,y2!) [,[color%] [,border%]]]\p

    ş \bSCREEN\p                 Specifies that coordinates are relative to the
                             screen rather than the viewport.
    ş \b(x1!,y1!)-(x2!,y2!)\p    The coordinates of diagonally opposite corners
                             of the viewport.
    ş \bcolor%\p                 A color attribute that sets the viewport fill
                             color.
    ş \bborder%\p                A color attribute that sets the viewport border
                             color.

    ş If all arguments are omitted, the entire screen is the viewport.
    ş The available color attributes depend on your graphics adapter and the
      screen mode set by the most recent SCREEN statement.

Example:
    'This example requires a color graphics adapter.
    SCREEN 1
    VIEW (10, 10)-(300, 180), , 1
    LOCATE 1, 11: PRINT "A big graphics viewport";
    VIEW SCREEN (80, 80)-(200, 125), , 1
    LOCATE 11, 11: PRINT "A small graphics viewport";

See Also    \i\p\aCLS\v@CLS\v\i\p    \i\p\aSCREEN\v@SCREEN\v\i\p    \i\p\aVIEW PRINT\v@vupri\v\i\p    \i\p\aWINDOW\v@WINDOW\v\i\p
            \i\p\aColor Attributes and Values\v@color.table\v\i\p    \i\p\aScreen Modes\v@screen.modes\v\i\p
.comment ******************************************************************
.comment *  Math Family - QBasic                                          *
.comment ******************************************************************
.comment * 1/10/90 Cleaned comments.
.comment *    -- JeffWe
.comment ******************************************************************
.context ABS
.context @ABS
.context SGN
.context @SGN
:nABS, SGN Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
ABS returns the absolute value of a number.
SGN returns a value indicating the sign of a numeric expression (1 if the
expression is positive, 0 if it is zero, or -1 if it is negative).

\bABS(numeric-expression)\p
\bSGN(numeric-expression)\p

    ş \bnumeric-expression\p    Any numeric expression.

Example:
    PRINT ABS(45.5 - 100!)           'Output is:  54.5
    PRINT SGN(1), SGN(-1), SGN(0)    'Output is:  1  -1  0
.context ASC
.context @ASC
.context CHR$
.context @CHR$
:nASC, CHR$ Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
ASC returns the ASCII code for the first character in a string expression.
CHR$ returns the character corresponding to a specified ASCII code.

\bASC(stringexpression$)\p
\bCHR$(ascii-code%)\p

    ş \bstringexpression$\p    Any string expression.
    ş \bascii-code%\p          The ASCII code of the desired character.

Example:
    PRINT ASC("Q")    'Output is:  81
    PRINT CHR$(65)    'Output is:  A

See Also    \i\p\aASCII Character Codes\v@ac\v\i\p
.context ATN
.context @ATN
.context COS
.context @COS
.context SIN
.context @SIN
.context TAN
.context @TAN
:nATN, COS, SIN, TAN Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
ATN returns the arctangent of a specified numeric expression.
COS, SIN, and TAN return the cosine, sine, and tangent of a specified angle.

\bATN(numeric-expression)\p
\bCOS(angle)\p
\bSIN(angle)\p
\bTAN(angle)\p

    ş \bnumeric-expression\p    The ratio between the sides of a right triangle.
    ş \bangle\p                 An angle expressed in radians.

    ş The ATN function returns an angle in radians.
    ş To convert from degrees to radians, multiply degrees by (PI / 180).

Example:
    CONST PI=3.141592654
    PRINT ATN(TAN(PI/4.0)), PI/4.0    'Output is:  .7853981635  .7853981635
    PRINT (COS(180 * (PI / 180)))     'Output is:  -1
    PRINT (SIN(90 * (PI / 180)))      'Output is:  1
    PRINT (TAN(45 * (PI / 180)))      'Output is:  1.000000000205103
.context CDBL
.context @CDBL
.context CSNG
.context @CSNG
:nCDBL, CSNG Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
CDBL converts a numeric expression to a double-precision value.
CSNG converts a numeric expression to a single-precision value.

\bCDBL(numeric-expression)\p
\bCSNG(numeric-expression)\p

    ş \bnumeric-expression\p    Any numeric expression.

Example:
    PRINT 1 / 3, CDBL(1 / 3)    'Output is:  .3333333  .3333333333333333
    PRINT CSNG(975.3421515#)    'Output is:  975.3422

See Also    \i\p\aCINT, CLNG\v@CINT\v\i\p
.context CINT
.context @CINT
.context CLNG
.context @CLNG
:nCINT, CLNG Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
CINT rounds a numeric expression to an integer.
CLNG rounds a numeric expression to a long (4-byte) integer.

\bCINT(numeric-expression)\p
\bCLNG(numeric-expression)\p

    ş \bnumeric-expression\p    For CINT, any numeric expression in the range
                            -32,768 through 32,767.
                            For CLNG, any numeric expression in the range
                            -2,147,483,648 through 2,147,483,647.

Example:
    PRINT CINT(12.49), CINT(12.51)    'Output is:  12  13
    PRINT CLNG(338457.8)              'Output is:  338458

See Also    \i\p\aCDBL, CSNG\v@CDBL\v\i\p    \i\p\aFIX, INT\v@FIX\v\i\p
.context .datef
.context @datef
.context DATE$
.context @DATE$
:nDATE$ Function and Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
The DATE$ function returns the computer's current system date.
The DATE$ statement sets the current system date on your computer.

\bDATE$\p
\bDATE$ = stringexpression$\p

    ş \bstringexpression$\p    The date in one of the following forms:
                           mm-dd-yy, mm-dd-yyyy, mm/dd/yy, mm/dd/yyyy.

    ş The DATE$ function returns a string in the form mm-dd-yyyy.

Example:
    PRINT DATE$
    DATE$ = "01-01-90"    'Note: The new system date remains in effect until
                          '      you change it again.
    PRINT "Date set to "; DATE$

See Also    \i\p\aTIME$\v@TIME$\v\i\p
.context EXP
.context @EXP
.context LOG
.context @LOG
:nEXP, LOG Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
EXP returns e raised to a specified power, where e is the base of natural
logarithms. LOG returns the natural logarithm of a numeric expression.

\bEXP(numeric-expression)\p
\bLOG(numeric-expression)\p

    ş \bnumeric-expression\p    For EXP, a number less than or equal to 88.02969.
                            For LOG, any positive numeric expression.

Example:
    PRINT EXP(0), EXP(1)         'Output is:  1  2.718282
    PRINT LOG(1), LOG(EXP(1))    'Output is:  0  1
.context FIX
.context @FIX
.context INT
.context @INT
:nFIX, INT Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
FIX truncates a floating-point expression to its integer portion.
INT returns the largest integer less than or equal to a numeric expression.

\bFIX(numeric-expression)\p
\bINT(numeric-expression)\p

    ş \bnumeric-expression\p    Any numeric expression.

Example:
    PRINT FIX(12.49), FIX(12.54)    'Output is:  12  12
    PRINT INT(12.54), INT(-99.4)    'Output is:  12  -100

See Also    \i\p\aCINT, CLNG\v@CINT\v\i\p
.context RANDOMIZE
.context @RANDOMIZE
.context RND
.context @RND
:nRANDOMIZE Statement, RND Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
RANDOMIZE initializes the random-number generator.
RND returns a single-precision random number between 0 and 1.

\bRANDOMIZE [seed%]\p
\bRND[(n#)]\p

    ş \bseed%\p    A number used to initialize the random-number generator.
               If omitted, RANDOMIZE prompts for it.
    ş \bn#\p       A value that sets how RND generates the next random number:

               n#                             RND returns
               ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
               Less than 0                    The same number for any n#
               Greater than 0 (or omitted)    The next random number
               0                              The last number generated

Example:
    RANDOMIZE TIMER
    x% = INT(RND * 6) + 1
    y% = INT(RND * 6) + 1
    PRINT "Roll of two dice: die 1 ="; x%; "and die 2 ="; y%
.context SQR
.context @SQR
:nSQR Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the square root of a numeric expression.

\bSQR(numeric-expression)\p

    ş \bnumeric-expression\p    A value greater than or equal to zero.

Example:
    PRINT SQR(25), SQR(2)    'Output is:  5  1.414214
.context .tmf
.context @tmf
.context TIME$
.context @TIME$
:nTIME$ Function and Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
The TIME$ function returns the computer's current system time.
The TIME$ statement sets the current system time on your computer.

\bTIME$\p
\bTIME$ = stringexpression$\p

    ş \bstringexpression$\p    The time in one of the following forms:
                             hh          Sets the hour; minutes and seconds
                                         default to 00.
                             hh:mm       Sets the hour and minutes; seconds
                                         default to 00.
                             hh:mm:ss    Sets the hour, minutes, and seconds.

    ş The TIME$ function returns a string in the form hh:mm:ss.

Example:
    PRINT TIME$
    TIME$ = "08:00:58"    'Note: The new system time remains in effect until
                          '      you change it again.
    PRINT "Time set to "; TIME$

See Also    \i\p\aDATE$\v@DATE$\v\i\p
.comment ******************************************************************
.comment *  One arithmetic operator                                       *
.comment ******************************************************************
.context MOD
.context @MOD
:nMOD Arithmetic Operator
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Divides one number by another and returns the remainder.

\bnumeric-expression1 MOD numeric-expression2\p

    ş \bnumeric-expression1\p    Any numeric expressions. Real numbers are
      \bnumeric-expression2\p    rounded to integers.

Example:
    PRINT 19 MOD 6.7    'QBasic rounds 6.7 to 7, then divides.
                        'Output is:  5
.comment ******************************************************************
.comment *  Procedure Family - QBasic                                     *
.comment ******************************************************************
.comment * 1/10/90 Cleaned comments.
.comment *    -- JeffWe
.comment ******************************************************************
.context CONST
.context @CONST
:nCONST Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Declares one or more symbolic constants.

\bCONST constantname = expression [,constantname = expression]...\p

    ş \bconstantname\p    The name of the constant. This name can consist of up
                      to 40 characters and must begin with a letter. Valid
                      characters are A-Z, 0-9, and period (.).
    ş \bexpression\p      An expression that is assigned to the constant. The
                      expression can consist of literals (such as 1.0), other
                      constants, any arithmetic or logical operators except
                      exponentiation (^), or a single literal string.

Example:
    CONST PI = 3.141593
    INPUT "Radius of Circle: "; r
    PRINT "Area = "; PI * r ^ 2
.context DECLARE
.context @DECLARE
.context ANY
.context @ANY
:nDECLARE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Declares a FUNCTION or SUB procedure and invokes argument data type checking.

\bDECLARE {FUNCTION | SUB} name [([parameterlist])]\p

    ş \bname\p             The name of the procedure.
    ş \bparameterlist\p    One or more variables that specify parameters to be
                       passed to the procedure when it is called:

                       \bvariable[( )] [AS type] [, variable[( )] [AS type]]...\p

		       \bvariable\p    A Basic variable name.
                       \btype\p        The data type of the variable (INTEGER,
                                   LONG, SINGLE, DOUBLE, STRING, or a
                                   user-defined data type). ANY allows any
                                   data type.

    ş DECLARE is required if you call SUB procedures without CALL. QBasic
      automatically generates DECLARE statements when you save your program.

Example:
    The program REMLINE.BAS illustrates declaring FUNCTION and SUB
    procedures. To view or run this program, load REMLINE.BAS using the Open
    command from the File menu.

See Also    \i\p\aCALL\v@CALL\v\i\p    \i\p\aFUNCTION\v@FUNCTION\v\i\p    \i\p\aSUB\v@SUB\v\i\p
.context DEF
.context @DEF
:nDEF FN Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Defines a function.

\bDEF FNname[(parameterlist)] = expression\p
\bDEF FNname[(parameterlist)]\p
    \b[statementblock]\p
  \bFNname = expression\p
    \b[statementblock]\p
  \bEXIT DEF]\p
    \b[statementblock]\p
  \bEND DEF\p

    ş \bparameterlist\p    One or more arguments in the following form:

                       \bvariable[( )] [AS type] [, variable[( )] [AS type]]...\p

		       \bvariable\p    A Basic variable name.
                       \btype\p        The data type of the variable (INTEGER,
                                   LONG, SINGLE, DOUBLE, STRING, or a
                                   user-defined data type).

    ş \bexpression\p       The return value of the function.

    ş The FUNCTION statement provides a better way to define a function.

See Also    \i\p\aEXIT\v@EXIT\v\i\p    \i\p\aFUNCTION\v@FUNCTION\v\i\p    \i\p\aSHARED, STATIC\v@STATIC\v\i\p
.context ENVIRON
.context @ENVIRON
.context ENVIRON$
.context @ENVIRON$
:nENVIRON$ Function, ENVIRON Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
ENVIRON$ returns a DOS environment string.
ENVIRON changes or adds an environment string in the DOS environment table.

\bENVIRON$ (env-variable$)\p
\bENVIRON$ (n%)\p
\bENVIRON stringexpression$\p

    ş \benv-variable$\p        The name of a DOS environment variable.
    ş \bn%\p                   Specifies that ENVIRON$ returns the nth string
                           from the environment string table.
    ş \bstringexpression$\p    The name and setting of a DOS environment
                           variable (such as PATH or PROMPT) in one of the
                           following forms:

                           \benv-variable$=env-string$\p
                           \benv-variable$ env-string$\p

    ş Changes made by the ENVIRON statement are erased when the program ends.

Example:
    ENVIRON "PATH=TEST"
    PRINT ENVIRON$("PATH")
.context FUNCTION
.context @FUNCTION
:nFUNCTION Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Defines a FUNCTION procedure.

\bFUNCTION name [(parameterlist)] [STATIC]\p
    \b[statementblock]\p
  \bname = expression\p
    \b[statementblock]\p
\bEND FUNCTION\p

    ş \bname\p             The name of the function and the data type it returns,
                       specified by a data-type suffix (%, &, !, #, or $).
    ş \bparameterlist\p    One or more variables that specify parameters to be
                       passed to the function when it is called:

                       \bvariable[( )] [AS type] [, variable[( )] [AS type]]...\p

		       \bvariable\p    A Basic variable name.
                       \btype\p        The data type of the variable (INTEGER,
                                   LONG, SINGLE, DOUBLE, STRING, or a
                                   user-defined data type).

    ş \bSTATIC\p           Specifies that the values of the function's local
                       variables are saved between function calls.
    ş \bexpression\p       The return value of the function.

    ş When you call the function, you can specify that an argument's value
      will not be changed by the function by enclosing the argument in
      parentheses.


Example:
    The program REMLINE.BAS illustrates calling FUNCTION procedures. To view
    or run this program, load REMLINE.BAS using the Open command from the
    File menu.

See Also    \i\p\aDECLARE\v@DECLARE\v\i\p    \i\p\aDEF FN\v@DEF\v\i\p    \i\p\aEXIT\v@EXIT\v\i\p    \i\p\aSHARED, STATIC\v@STATIC\v\i\p    \i\p\aSUB\v@SUB\v\i\p
.context SHELL
.context @SHELL
:nSHELL Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Suspends execution of a Basic program to run a DOS command or batch file.

\bSHELL [commandstring$]\p

    ş \bcommandstring$\p    The name of a DOS command or batch file.

    ş Your program resumes when the DOS command or batch file completes.
    ş If you omit the command string, SHELL invokes a DOS shell and displays
      the DOS prompt. Use the EXIT command to resume your program.

Example:
    SHELL "DIR"
.context SUB
.context @SUB
:nSUB Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Defines a SUB procedure.

\bSUB name[(parameterlist)] [STATIC]\p
  \b[statementblock]\p
\bEND SUB\p

    ş \bname\p             The name of the SUB procedure, up to 40 characters
                       long, with no data type suffix.
    ş \bparameterlist\p    One or more variables that specify parameters to be
                       passed to the SUB procedure when it is called:

                       \bvariable[( )] [AS type] [, variable[( )] [AS type]]...\p

		       \bvariable\p    A Basic variable name.
                       \btype\p        The data type of the variable (INTEGER,
                                   LONG, SINGLE, DOUBLE, STRING, or a
                                   user-defined data type).

    ş \bSTATIC\p           Specifies that the values of the SUB procedure's
                       local variables are saved between function calls.

    ş When you call the SUB procedure, you can specify that an argument's
      value will not be changed by the procedure by enclosing the argument
      in parentheses.

Example:
    The program REMLINE.BAS illustrates calling SUB procedures. To view or
    run this program, load REMLINE.BAS using the Open command from the File
    menu.

See Also    \i\p\aCALL\v@CALL\v\i\p    \i\p\aDECLARE\v@DECLARE\v\i\p    \i\p\aEXIT\v@EXIT\v\i\p    \i\p\aFUNCTION\v@FUNCTION\v\i\p    \i\p\aSHARED, STATIC\v@STATIC\v\i\p
.comment ******************************************************************
.comment *  Event Trapping Family - QBasic                                *
.comment ******************************************************************
.comment * 1/10/91 Cleaned up comments.
.comment *   -- JeffWe
.comment ******************************************************************
.context COM
.context @COM
:nCOM, ON COM Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
COM enables, disables, or suspends event trapping on a communications port.
If event trapping is enabled, ON COM branches to a subroutine whenever
characters are received at the port.

\bCOM(n%) ON\p
\bCOM(n%) OFF\p
\bCOM(n%) STOP\p
\bON COM(n%) GOSUB line\p

    ş \bn%\p              The number of a COM (serial) port (1 or 2).
    ş \bCOM(n%) ON\p      Enables trapping of a communications event.
    ş \bCOM(n%) OFF\p     Disables communications event trapping.
    ş \bCOM(n%) STOP\p    Suspends communications event trapping. Events are
                      processed once event trapping is enabled by COM ON.
    ş \bline\p            The label or number of the first line of the
                      event-trapping subroutine.

Example:
    COM(1) ON       'Enable event trapping on port 1.
    ON COM(1) GOSUB ComHandler
    DO : LOOP WHILE INKEY$ = ""
    COM(1) OFF
    END

    ComHandler:
        PRINT "Something was typed at the terminal attached to COM1."
        RETURN

See Also    \i\p\aOPEN COM\v@opcom\v\i\p
.context .ketv
.context @ketv
:nKEY, ON KEY Statements (Event Trapping)
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
KEY enables, disables, or suspends event trapping of a key.
If event trapping is enabled, ON KEY branches to a subroutine whenever
the key is pressed.

\bKEY(n%) ON\p
\bKEY(n%) OFF\p
\bKEY(n%) STOP\p
\bON KEY(n%) GOSUB line\p

    ş \bn%\p              A value that specifies a function key, direction key,
                      or user-defined key:

                      n%        Key
                      ÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                      0         All keys listed here (KEY(0) ON, KEY(0) OFF,
                                and KEY(0) STOP only).
                      1-10      Function keys F1-F10.
                      11        Up Arrow key.
                      12        Left Arrow key.
                      13        Right Arrow key.
                      14        Down Arrow key.
                      15-25     User-defined keys. For more information,
                                see \i\p\aDeclaring User-Defined Keys\v@kbflags\v\i\p.
                      30, 31    Function keys F11 and F12.

    ş \bKEY(n%) ON\p      Enables event trapping for the specified key.
    ş \bKEY(n%) OFF\p     Disables key event trapping.
    ş \bKEY(n%) STOP\p    Suspends key event trapping. Events are processed
                      once event trapping is enabled by KEY ON.
    ş \bline\p            The label or number of the first line of the
                      event-trapping subroutine.

Example:
    'This example requires Caps Lock and Num Lock to be off.
    CONST ESC = 27
    KEY 15, CHR$(&H4) + CHR$(&H1F)              'Set up Ctrl+S as KEY 15.
    ON KEY(15) GOSUB PauseHandler
    KEY(15) ON
    WHILE INKEY$ <> CHR$(ESC)
        PRINT "Press Esc to stop, Ctrl+S to pause."
        PRINT
    WEND
    END

    PauseHandler:
        SLEEP 1
        RETURN

See Also    \i\p\aKEY (Assignment)\v@KEY\v\i\p    \i\p\aDeclaring User-Defined Keys\v@kbflags\v\i\p
.context .kbflags
.context @kbflags
:nDeclaring User-Defined Keys
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
To declare a user-defined key, use the following variation of the KEY
statement:

\bKEY n%, CHR$(keyboardflag%) + CHR$(scancode%)\p

    ş \bn%\p               A value in the range 15 through 25 that identifies
                       the key.
    ş \bkeyboardflag%\p    One of the following values, or a sum of values,
                       specifying whether the user-defined key is used in
                       combination with the Shift, Ctrl, Alt, NumLock, or
                       Caps Lock keys, or with extended keys:

                       Value            Key
                       ÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                       0                No keyboard flag
                       1 through 3      Either Shift key
                       4                Ctrl key
                       8                Alt key
                       32               NumLock key
                       64               Caps Lock key
                       128              Extended keys on a 101-key keyboard

                       To specify multiple shift states, add the values
                       together. For example, a value of 12 specifies that
                       the user-defined key is used in combination with
                       the Ctrl and Alt keys.

    ş \bscancode%\p        The scan code for the key being declared.
                       See \i\p\aKeyboard Scan Codes\v@kbsct\v\i\p.

See Also    \i\p\aKEY (Assignment)\v@KEY\v\i\p    \i\p\aKEY, ON KEY (Event Trapping)\v@ketv\v\i\p
.context PEN
.context @PEN
:nPEN, ON PEN Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
PEN enables, disables, or suspends light-pen event trapping.
If event trapping is enabled, ON PEN branches to a subroutine whenever
the light pen is activated.

\bPEN ON\p
\bPEN OFF\p
\bPEN STOP\p
\bON PEN GOSUB line\p

    ş \bPEN ON\p      Enables light-pen event trapping.
    ş \bPEN OFF\p     Disables light-pen event trapping.
    ş \bPEN STOP\p    Suspends light-pen event trapping. Events are processed
                  once event trapping is enabled by PEN ON.
    ş \bline\p        The label or number of the first line of the
                  event-trapping subroutine.

Example:
    'This example requires a light pen.
    ON PEN GOSUB Handler
    PEN ON
    PRINT "Press Esc to exit."
    DO UNTIL INKEY$ = CHR$(27): LOOP
    END

Handler:
    PRINT "Pen is at row"; PEN(6); ", column"; PEN(7)
    RETURN


See Also    \i\p\aPEN Function\v@penf\v\i\p
.context .playf
.context @playf
:nPLAY Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the number of notes in the background music queue.

\bPLAY(n)\p

    ş \bn\b    Any numeric expression.

Example:
    Music$ = "MBT180o2P2P8L8GGGL2E-P24P8L8FFFL2D"
    PLAY Music$
    WHILE PLAY(0) > 5: WEND
    PRINT "Just about done!"

See Also    \i\p\aPLAY (Music)\v@PLAY\v\i\p    \i\p\aPLAY, ON PLAY (Event Trapping)\v@playev\v\i\p
.context .playev
.context @playev
:nPLAY, ON PLAY Statements (Event Trapping)
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
PLAY enables, disables, or suspends play event trapping.
If event trapping is enabled, ON PLAY branches to a subroutine whenever
the music buffer contains fewer than a specified number of notes.

\bPLAY ON\p
\bPLAY OFF\p
\bPLAY STOP\p
\bON PLAY(queuelimit%) GOSUB line\p

    ş \bPLAY ON\p        Enables play event trapping.
    ş \bPLAY OFF\p       Disables play event trapping.
    ş \bPLAY STOP\p      Suspends play event trapping. Events are processed once
                     event trapping is enabled by PLAY ON.
    ş \bqueuelimit%\p    A number in the range 1 through 32. ON PLAY branches to
                     a subroutine when there are fewer than queuelimit%
                     notes in the music buffer.
    ş \bline\p           The label or number of the first line of the
                     event-trapping subroutine.

Example:
    ON PLAY(3) GOSUB Background
    PLAY ON
    Music$ = "MBo3L8ED+ED+Eo2Bo3DCL2o2A"
    PLAY Music$
    LOCATE 2, 1: PRINT "Press any key to stop.";
    DO WHILE INKEY$ = "": LOOP
    END

    Background:
        i% = i% + 1
        LOCATE 1, 1: PRINT "Background called "; i%; "time(s)";
        PLAY Music$
        RETURN

See Also    \i\p\aPLAY (Music)\v@PLAY\v\i\p    \i\p\aPLAY Function\v@playf\v\i\p
.context .strigf
.context @strigf
:nSTRIG Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the status of a joystick trigger.

\bSTRIG(n%)\p

    ş \bn%\p    A value that specifies a joystick status condition:

            n%    Condition
            ÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
            0     Lower joystick A trigger was pressed since last STRIG(0)
            1     Lower joystick A trigger is currently pressed
            2     Lower joystick B trigger was pressed since last STRIG(2)
            3     Lower joystick B trigger is currently pressed
            4     Upper joystick A trigger was pressed since last STRIG(4)
            5     Upper joystick A trigger is currently pressed
            6     Upper joystick B trigger was pressed since last STRIG(6)
            7     Upper joystick B trigger is currently pressed

    ş STRIG returns -1 if the condition is true, 0 otherwise.

Example:
    PRINT "Press Esc to exit."
    DO
        IF STRIG(0) OR INKEY$ = CHR$(27) THEN EXIT DO
    LOOP
    DO
        BEEP                  'BEEP while trigger A is pressed.
    LOOP WHILE STRIG(1)

See Also    \i\p\aSTICK\v@STICK\v\i\p    \i\p\aSTRIG, ON STRIG Statements\v@STRIG\v\i\p
.context STRIG
.context @STRIG
:nSTRIG, ON STRIG Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
STRIG enables, disables, or suspends joystick event trapping.
If event trapping is enabled, ON STRIG branches to a subroutine whenever
a specified joystick trigger is pressed.

\bSTRIG(n%) ON\p
\bSTRIG(n%) OFF\p
\bSTRIG(n%) STOP\p
\bON STRIG(n%) GOSUB line\p

    ş \bn%\p                A value that specifies a joystick trigger:

                        n%    Trigger
                        ÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                        0     Lower trigger, joystick A
                        2     Lower trigger, joystick B
                        4     Upper trigger, joystick A
                        6     Upper trigger, joystick B

    ş \bSTRIG(n%) ON\p      Enables joystick event trapping.
    ş \bSTRIG(n%) OFF\p     Disables joystick event trapping.
    ş \bSTRIG(n%) STOP\p    Suspends joystick event trapping. Events are
                        processed once event trapping is enabled by STRIG ON.
    ş \bline\p              The label or number of the first line of the
                        event-trapping subroutine.

Example:
    'This example requires a joystick.
    ON STRIG(0) GOSUB Handler
    STRIG(0) ON
    PRINT "Press Esc to exit."
    DO UNTIL INKEY$ = CHR$(27): LOOP
    END

Handler:
    PRINT "Joystick trigger is depressed."
    RETURN

See Also    \i\p\aSTICK\v@STICK\v\i\p    \i\p\aSTRIG Function\v@strigf\v\i\p
.context .timerf
.context @timerf
:nTIMER Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the number of seconds elapsed since midnight.

\bTIMER\p

    ş Use TIMER to time programs or parts of programs, or with the RANDOMIZE
      statement to seed the random-number generator.

Example:
    RANDOMIZE TIMER

See Also    \i\p\aRANDOMIZE, RND\v@randomize\v\i\p    \i\p\aTIMER, ON TIMER Statements\v@TIMER\v\i\p
.context TIMER
.context @TIMER
:nTIMER, ON TIMER Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ\p
TIMER enables, disables, or suspends timer event trapping.
If event trapping is enabled, ON TIMER branches to a subroutine whenever
a specified number of seconds has elapsed.

\bTIMER ON\p
\bTIMER OFF\p
\bTIMER STOP\p
\bON TIMER(n%) GOSUB line\p

    ş \bTIMER ON\p      Enables timer event trapping.
    ş \bTIMER OFF\p     Disables timer event trapping.
    ş \bTIMER STOP\p    Suspends timer event trapping. Events are processed
                    once event trapping is enabled by TIMER ON.
    ş \bn%\p            The number of seconds that elapse before ON TIMER
                    branches to the event-trapping subroutine; a value in
                    the range 1 through 86,400 (24 hours).
    ş \bline\p          The label or number of the first line of the
                    event-trapping subroutine.

Example:
    ON TIMER(1) GOSUB TimeUpdate
    TIMER ON
    CLS
    PRINT "Time: "; TIME$
    StartTime = TIMER
    WHILE TimePast < 10
        TimePast = TIMER - StartTime
    WEND
    END

    TimeUpdate:
        LOCATE 1, 7: PRINT TIME$
        RETURN

See Also    \i\p\aTIMER Function\v@timerf\v\i\p
.comment *******************************************************************
.comment *  ON and OFF keyword screens follow.
.comment *******************************************************************
.context ON
.context @ON
:nON Keyword
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Performs different actions as part of several statements:

    ş Enables error trapping when used with the ON ERROR statement.
    ş Enables event trapping when used with the event ON statements
      (COM ON, KEY ON, PEN ON, PLAY ON, STRIG ON, and TIMER ON).
    ş Specifies an event to trap when used with the ON event statements
      (ON COM, ON KEY, ON PEN, ON PLAY, ON STRING, and ON TIMER).
    ş Specifies an expression to evaluate when used with the ON...GOSUB
      and ON...GOTO statements.

See Also    \i\p\aCOM, ON COM\v@COM\v\i\p      \i\p\aKEY, ON KEY\v@ketv\v\i\p        \i\p\aON ERROR\v@onerr\v\i\p
            \i\p\aON...GOSUB, ON...GOTO\v@ongo\v\i\p                 \i\p\aPEN, ON PEN\v@PEN\v\i\p
            \i\p\aPLAY, ON PLAY\v@playev\v\i\p    \i\p\aSTRIG, ON STRIG\v@STRIG\v\i\p    \i\p\aTIMER, ON TIMER\v@TIMER\v\i\p
.context OFF
.context @OFF
:nOFF Keyword - Different Uses
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turns off the display of function key assignments when used with the
KEY (Assignment) statement, or disables event trapping when used with the
event OFF statements (COM OFF, KEY OFF, PEN OFF, PLAY OFF, STRIG OFF, and
TIMER OFF).

See Also    \i\p\aCOM, ON COM\v@COM\v\i\p    \i\p\aKEY, ON KEY\v@ketv\v\i\p      \i\p\aKEY (Assignment)\v@KEY\v\i\p
            \i\p\aPEN, ON PEN\v@PEN\v\i\p    \i\p\aPLAY, ON PLAY\v@playev\v\i\p    \i\p\aSTRIG, ON STRIG\v@STRIG\v\i\p
            \i\p\aTIMER, ON TIMER\v@TIMER\v\i\p
.comment ******************************************************************
.comment *  Structure Family - QBasic                                     *
.comment ******************************************************************
.comment * 1/10/90 Cleaned comments.
.comment *    -- JeffWe
.comment ******************************************************************
.context $STATIC
.context @$STATIC
.context $DYNAMIC
.context @$DYNAMIC
:n$STATIC, $DYNAMIC Metacommands
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Set the default array storage.

\b{REM | '} $STATIC\p
\b{REM | '} $DYNAMIC\p

    ş \b{REM | '}\p    REM or a remark character (') must precede metacommands.
    ş \b$STATIC\p      Specifies that arrays declared in subsequent DIM
                   statements are static arrays (unless they are declared in
                   a non-static SUB or FUNCTION procedure). Array storage is
                   allocated when you start the program, and remains fixed.
    ş \b$DYNAMIC\p     Specifies that arrays declared in subsequent DIM
                   statements are dynamic arrays. Array storage is allocated
                   dynamically while the program runs.

    ş DIM and REDIM usually provide a better way to specify whether arrays
      are dynamic or static.

See Also    \i\p\aDIM, REDIM\v@DIM\v\i\p    \i\p\aREM\v@REM\v\i\p    \i\p\aSHARED, STATIC\v@STATIC\v\i\p
.context COMMON
.context @COMMON
:nCOMMON Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Defines global variables that can be shared throughout a program or between
chained programs.

\bCOMMON [SHARED] variablelist\p

    ş \bSHARED\p          Indicates that variables are shared with all SUB
                      or FUNCTION procedures.
    ş \bvariablelist\p    One or more variables to be shared:

                      \bvariable[( )] [AS type] [, variable[( )] [AS type]]...\p

		      \bvariable\p    A Basic variable name. Variable names can
                                  consist of up to 40 characters and must
                                  begin with a letter. Valid characters are
                                  A-Z, 0-9, and period (.).
                      \btype\p        The data type of the variable (INTEGER,
                                  LONG, SINGLE, DOUBLE, STRING, or a
                                  user-defined data type).

    ş Unless it has been declared as a static array in a preceding DIM
      statement, an array variable in a COMMON statement is a dynamic array.
      Its dimensions must be set in a later DIM or REDIM statement.

See Also    \i\p\aCHAIN\v@CHAIN\v\i\p    \i\p\aDIM, REDIM\v@DIM\v\i\p    \i\p\aFUNCTION\v@FUNCTION\v\i\p
            \i\p\aSHARED, STATIC\v@SHARED\v\i\p           \i\p\aSUB\v@SUB\v\i\p
.context DATA
.context @DATA
.context READ
.context @READ
.context RESTORE
.context @RESTORE
:nDATA, READ, RESTORE Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
DATA specifies values to be read by subsequent READ statements.
READ reads those values and assigns them to variables.
RESTORE allows READ to reread values in specified DATA statements.

\bDATA constant[,constant]...\p
\bREAD variablelist\p
\bRESTORE [line]\p

    ş \bconstant\p        One or more numeric or string constants specifying
                      the data to be read. String constants containing
                      commas, colons, or leading or trailing spaces are
                      enclosed in quotation marks (" ").
    ş \bvariablelist\p    One or more variables, separated by commas, that are
                      assigned data values. Variable names can consist of up
                      to 40 characters and must begin with a letter. Valid
                      characters are A-Z, 0-9, and period (.).
    ş \bline\p            The label or line number of a DATA statement. If line
                      is omitted, the next READ statement reads values in
                      the first DATA statement in the program.

    ş DATA statements can be entered only at the module level. They cannot
      be used in procedures.

Example:
    FOR i% = 1 TO 3
        READ a%, b$
        PRINT a%, b$
        RESTORE
    NEXT i%
    DATA 1, "Repeat"
.context DEFINT
.context @DEFINT
.context DEFLNG
.context @DEFLNG
.context DEFSNG
.context @DEFSNG
.context DEFDBL
.context @DEFDBL
.context DEFSTR
.context @DEFSTR
:nDEFtype Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Sets the default data type for variables, DEF FN functions, and FUNCTION
procedures.

\bDEFINT letterrange [,letterrange]...\p
\bDEFLNG letterrange [,letterrange]...\p
\bDEFSNG letterrange [,letterrange]...\p
\bDEFDBL letterrange [,letterrange]...\p
\bDEFSTR letterrange [,letterrange]...\p

    ş \bletterrange\p    A letter or range of letters (such as A-M). QBasic
                     sets the default data type for variables, DEF FN
                     functions, and FUNCTION procedures whose names begin
                     with the specified letter or letters as follows:

                     Statement    Default Data Type
                     ÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                     DEFINT       Integer
                     DEFLNG       Long integer
                     DEFSNG       Single precision
                     DEFDBL       Double precision
                     DEFSTR       String

    ş A data-type suffix (%, &, !, #, or $) always takes precedence over a
      DEFtype statement.
    ş Single-precision is the default data type if you do not specify a
      DEFtype statement.
    ş After you specify a DEFtype statement in your program, QBasic
      automatically inserts a corresponding DEFtype statement in each
      procedure you create.

Example:
    DEFDBL A-Z
    a = SQR(3)
    PRINT "Square root of 3 = "; a

See Also    \i\p\aDifferences from BASICA\v@basica.diffs\v\i\p
.context DIM
.context @DIM
.context REDIM
.context @REDIM
:nDIM, REDIM Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
DIM declares an array or specifies a data type for a nonarray variable.
REDIM declares or resizes a dynamic array, erasing any previous values.

\bDIM [SHARED] variable[(subscripts)] [AS type]\p
             \b[,variable[(subscripts)] [AS type]]...\p
\bREDIM [SHARED] variable(subscripts) [AS type]\p
               \b[,variable(subscripts) [AS type]]...\p

    ş \bSHARED\p        Specifies that variables are shared with all SUB or
                    FUNCTION procedures in the module.
    ş \bvariable\p      The name of an array or variable.
    ş \bsubscripts\p    Dimensions of the array, expressed as follows:

                    \b[lower TO] upper [,[lower TO] upper]...\p

                    \blower\p    The lower bound of the array's subscripts. The
                             default lower bound is zero.
                    \bupper\p    The upper bound.

    ş \bAS type\p       Declares the data type of the array or variable
                    (INTEGER, LONG, SINGLE, DOUBLE, STRING, or a
                    user-defined data type).

    ş DIM declares either static or dynamic arrays. Unless array storage has
      been determined by $STATIC, $DYNAMIC, or COMMON, arrays dimensioned
      with numbers are static and arrays dimensioned with variables are
      dynamic. REDIM always declares dynamic arrays.
    ş Static array storage is allocated when you start a program and
      remains fixed. Dynamic array storage is allocated while a program runs.

Example:
    ' $DYNAMIC
    DIM A(49, 49)
    REDIM A(19, 14)

See Also    \i\p\aCOMMON\v@COMMON\v\i\p    \i\p\aERASE\v@ERASE\v\i\p    \i\p\aOPTION BASE\v@BASE\v\i\p    \i\p\aSHARED, STATIC\v@SHARED\v\i\p
            \i\p\a$STATIC, $DYNAMIC\v@$DYNAMIC\v\i\p    \i\p\aDifferences from BASICA\v@basica.diffs\v\i\p
.context ERASE
.context @ERASE
:nERASE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Reinitializes array elements or frees dynamic array storage space.

\bERASE arrayname [,arrayname]...\p

    ş \barrayname\p    The name of an array.

    ş For static arrays, ERASE sets each element of a numeric array to zero
      and each element of a string array to null.
    ş For dynamic arrays, ERASE frees the memory used by the array. You must
      redeclare the array's dimensions with REDIM or DIM before using it.

Example:
    DIM a%(0)
    a%(0) = 6
    PRINT "Before: "; a%(0)
    ERASE a%
    PRINT "After: "; a%(0)

See Also    \i\p\aCLEAR\v@CLEAR\v\i\p    \i\p\aDIM, REDIM\v@DIM\v\i\p
.context LBOUND
.context @LBOUND
.context UBOUND
.context @UBOUND
:nLBOUND, UBOUND Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return the lower and upper bound (smallest or largest available subscript)
for the specified array dimension.

\bLBOUND(array[,dimension%])\p
\bUBOUND(array[,dimension%])\p

    ş \barray\p         The name of the array.
    ş \bdimension%\p    Indicates the array dimension whose lower or upper
                    bound is returned. Use 1 for the first dimension, 2
                    for the second dimension, etc. The default is 1.

Example:
    DIM a%(1 TO 3, 2 TO 7)
    PRINT LBOUND(a%, 1), UBOUND(a%, 2)

See Also    \i\p\aDIM, REDIM\v@DIM\v\i\p
.context LET
.context @LET
:nLET Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Assigns the value of an expression to a variable.

\b[LET] variable=expression\p

    ş \bvariable\p      Any variable. Variable names can consist of up to 40
                    characters and must begin with a letter. Valid characters
                    are A-Z, 0-9, and period (.).
    ş \bexpression\p    Any expression that provides a value to assign.

    ş Use of the optional LET keyword is not recommended. The
      variable=expression assignment statement performs the same action
      with or without LET.

See Also    \i\p\aLSET, RSET\v@LSET\v\i\p
.context OPTION
.context @OPTION
.context BASE
.context @BASE
:nOPTION BASE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Sets the default lower bound for array subscripts.

\bOPTION BASE {0 | 1}\p

    ş The DIM statement TO clause provides a better way to set the lower
      bound of an array subscript.

See Also    \i\p\aDIM, REDIM\v@DIM\v\i\p    \i\p\aLBOUND, UBOUND\v@UBOUND\v\i\p
.context REM
.context @REM
:nREM Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Allows explanatory remarks to be inserted in a program.

\bREM remark\p
\b' remark\p

    ş \bremark\p    Any text.

    ş Remarks are ignored when the program runs unless they contain
      metacommands.
    ş A remark can be inserted on a line after an executable statement if it
      is preceded by the single-quote (') form of REM or if REM is preceded
      by a colon (:).

Example:
    REM    This is a comment.
    '      This is also a comment.
    PRINT "Test1"       'This is a comment after a PRINT statement.
    PRINT "Test2" :  REM This is also a comment after a PRINT statement.

See Also    \i\p\a$STATIC, $DYNAMIC\v@$STATIC\v\i\p
.context SHARED
.context @SHARED
.context STATIC
.context @STATIC
:nSHARED, STATIC Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
SHARED gives procedures access to module-level variables.
STATIC makes a variable local to a function or procedure and preserves its
value between calls.

\bSHARED variable[()] [AS type] [,variable[()] [AS type]]...\p
\bSTATIC variable[()] [AS type] [,variable[()] [AS type]]...\p

    ş \bvariable\p    The name of the module-level variable to share or variable
                  to make static. Variable names can consist of up to 40
                  characters and must begin with a letter. Valid characters
                  are A-Z, 0-9, and period (.).
    ş \bAS type\p     Declares the data type of the variable (INTEGER, LONG,
                  SINGLE, DOUBLE, STRING, or a user-defined type).

Example:
    The program REMLINE.BAS illustrates using the SHARED and STATIC
    statements. To view or run this program, load REMLINE.BAS using the Open
    command from the File menu.

See Also    \i\p\aCOMMON\v@COMMON\v\i\p    \i\p\aDIM, REDIM\v@DIM\v\i\p
.context SWAP
.context @SWAP
:nSWAP Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Exchanges the values of two variables.

\bSWAP variable1, variable2\p

    ş \bvariable1\p and \bvariable2\p    Two variables of the same data type.

Example:
    a% = 1: b% = 2
    PRINT "Before: "; a%, b%
    SWAP a%, b%
    PRINT "After: "; a%, b%
.context TYPE
.context @TYPE
:nTYPE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Defines a data type containing one or more elements.

\bTYPE usertype\p
  \belementname AS typename\p
  \b[elementname AS typename]\p
\b.\p
\b.\p
\b.\p
\bEND TYPE\p

    ş \busertype\p       The name of the data type being defined. The name can
                     consist of up to 40 characters and must begin with a
                     letter. Valid characters are A-Z, 0-9, and period (.).
    ş \belementname\p    An element of the user-defined data type.
    ş \btypename\p       The element's type (INTEGER, LONG, SINGLE, DOUBLE,
                     STRING, or a user-defined data type).

    ş Use DIM, REDIM, COMMON, STATIC, or SHARED to create a variable of a
      user-defined data type.

Example:
    TYPE Card
        Suit AS STRING * 9
        Value AS INTEGER
    END TYPE
    DIM Deck(1 TO 52) AS Card
    Deck(1).Suit = "Club"
    Deck(1).Value = 2
    PRINT Deck(1).Suit, Deck(1).Value

See Also    \i\p\aCOMMON\v@COMMON\v\i\p    \i\p\aDIM, REDIM\v@DIM\v\i\p    \i\p\aSHARED, STATIC\v@SHARED\v\i\p
.comment ******************************************************************
.comment *  Data Type Keywords screen                                     *
.comment ******************************************************************
.context INTEGER
.context @INTEGER
.context LONG
.context @LONG
.context SINGLE
.context @SINGLE
.context DOUBLE
.context @DOUBLE
.context STRING
.context @STRING
:nData Type Keywords
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Specify the data type for a variable in a declarative statement or
parameter list:

    ş \bINTEGER\p      A 16-bit signed integer variable.
    ş \bLONG\p         A 32-bit signed integer variable.
    ş \bSINGLE\p       A single-precision 32-bit floating-point variable.
    ş \bDOUBLE\p       A double-precision 64-bit floating-point variable.
    ş \bSTRING * n%\p  A fixed-length string variable n% bytes long.
    ş \bSTRING\p       A variable-length string variable.

See Also    \i\p\aAS\v@AS\v\i\p	   \i\p\aBasic Character Set\v@fun.character.set\v\i\p	 \i\p\aCOMMON\v@COMMON\v\i\p
            \i\p\aDECLARE\v@DECLARE\v\i\p     \i\p\aDEF FN\v@DEF\v\i\p                       \i\p\aDIM, REDIM\v@DIM\v\i\p
            \i\p\aFUNCTION\v@FUNCTION\v\i\p    \i\p\aSHARED, STATIC\v@SHARED\v\i\p               \i\p\aSUB\v@SUB\v\i\p
            \i\p\aTYPE\v@TYPE\v\i\p
.comment ******************************************************************
.comment *  Control Family - QBasic                                       *
.comment ******************************************************************
.comment 01/09/91 - Cleaned up comments.
.comment -- JeffWe
.comment ******************************************************************
.comment *                                                                *
.context @CALL
.context CALL
:nCALL Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Transfers control to a SUB procedure.

\b[CALL] name [([argumentlist])]\p

    ş \bname\p            The name of the SUB procedure to call.
    ş \bargumentlist\p    The variables or constants to pass to the SUB
                      procedure. Separate multiple arguments with commas.
                      Specify array arguments with the array name followed
                      by empty parentheses.

    ş If you omit the CALL keyword, also omit the parentheses around
      argumentlist. Either declare the procedure in a DECLARE statement
      before calling it, or save the program and QBasic automatically
      generates a DECLARE statement.
    ş To specify an argument whose value will not be changed by the
      procedure, enclose the argument in parentheses.

Example:
    The program REMLINE.BAS illustrates calling SUB procedures. To view or
    run this program, load REMLINE.BAS using the Open command from the File
    menu.

See Also    \i\p\aCALL ABSOLUTE\v@ABSOLUTE\v\i\p    \i\p\aDECLARE\v@DECLARE\v\i\p    \i\p\aSUB\v@SUB\v\i\p
.context ABSOLUTE
.context @ABSOLUTE
:nCALL ABSOLUTE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Transfers control to a machine-language procedure.

\bCALL ABSOLUTE ([argumentlist,] offset%)\p

    ş \bargumentlist\p    Arguments passed to a machine-language procedure
                      as offsets from the current data segment.
    ş \boffset%\p         The offset from the current code segment, set by
                      DEF SEG, to the starting location of the procedure.

Example:
    'Calls routine for printing the screen to a local printer.
    DIM a%(2)
    DEF SEG = VARSEG(a%(0))
    FOR i% = 0 TO 2
       READ d%
       POKE VARPTR(a%(0)) + i%, d%
    NEXT i%
    DATA 205, 5, 203  : ' int 5  retf  'Machine-language code
                                       'for printing screen.
    CALL ABSOLUTE(VARPTR(a%(0)))
    DEF SEG

See Also    \i\p\aCALL\v@CALL\v\i\p    \i\p\aVARPTR, VARSEG\v@VARPTR\v\i\p    \i\p\aDifferences from BASICA\v@basica.diffs\v\i\p
.context CHAIN
.context @CHAIN
:nCHAIN Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Transfers control from the current program to another Basic program.

\bCHAIN filespec$\p

    ş \bfilespec$\p    The name of the program to which control is passed.

Example:
    'Assumes the program TEST.BAS is in a \\DOS directory.
    CHAIN "C:\\DOS\\TEST.BAS"

See Also    \i\p\aCALL\v@CALL\v\i\p    \i\p\aCOMMON\vCOMMON\v\i\p    \i\p\aRUN\vRUN\v\i\p    \i\p\aDifferences from BASICA\v@basica.diffs\v\i\p
.context DO
.context @DO
.context LOOP
.context @LOOP
.context UNTIL
.context @UNTIL
:nDO...LOOP Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Repeats a block of statements while a condition is true or until a condition
becomes true.

\bDO [{WHILE | UNTIL} condition]\p
    \b[statementblock]\p
\bLOOP\p

\bDO\p
    \b[statementblock]\p
\bLOOP [{WHILE | UNTIL} condition]\p

    ş \bcondition\p    A numeric expression that Basic evaluates as true
                   (nonzero) or false (zero).

Example:
    i% = 0
    PRINT "Value of i% at beginning of loop is  "; i%
    DO WHILE i% < 10
        i% = i% + 1
    LOOP
    PRINT "Value of i% at end of loop is  "; i%

See Also    \i\p\aEXIT\v@EXIT\v\i\p    \i\p\aFOR...NEXT\v@FOR\v\i\p    \i\p\aWHILE...WEND\v@WHILE\v\i\p
.context END
.context @END
:nEND Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Ends a program, procedure, block, or user-defined data type.

\bEND [{DEF | FUNCTION | IF | SELECT | SUB | TYPE}]\p

    ş \bDEF\p         Ends a multiline DEF FN function definition.
    ş \bFUNCTION\p    Ends a FUNCTION procedure definition.
    ş \bIF\p          Ends a block IF...THEN...ELSE statement.
    ş \bSELECT\p      Ends a SELECT CASE block.
    ş \bSUB\p         Ends a SUB procedure.
    ş \bTYPE\p        Ends a user-defined data type definition.

    ş If no argument is supplied, END ends the program and closes all files.

Example:
    PRINT "Game over."
    END

See Also    \i\p\aDEF FN\v@DEF\v\i\p    \i\p\aFUNCTION\v@FUNCTION\v\i\p    \i\p\aIF...THEN...ELSE\v@IF\v\i\p    \i\p\aSELECT CASE\v@IS\v\i\p
            \i\p\aSTOP\v@STOP\v\i\p      \i\p\aSUB\v@SUB\v\i\p         \i\p\aSYSTEM\v@SYSTEM\v\i\p              \i\p\aTYPE\v@TYPE\v\i\p
.context EXIT
.context @EXIT
:nEXIT Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Exits a DO or FOR loop, a FUNCTION or SUB procedure, or a DEF FN function.

\bEXIT {DEF | DO | FOR | FUNCTION | SUB}\p

    ş \bDEF\p         Exits a DEF FN function.
    ş \bDO\p          Exits a DO loop.
    ş \bFOR\p         Exits a FOR loop.
    ş \bFUNCTION\p    Exits a FUNCTION procedure.
    ş \bSUB\p         Exits a SUB procedure.

Example:
    i% = 0
    DO
        i% = i% + 1
        IF i% = 500 THEN EXIT DO
    LOOP
    PRINT "EXIT at"; i%

See Also    \i\p\aDEF FN\v@DEF\v\i\p    \i\p\aDO...LOOP\v@DO\v\i\p    \i\p\aFOR...NEXT\v@FOR\v\i\p    \i\p\aFUNCTION\v@FUNCTION\v\i\p    \i\p\aSUB\v@SUB\v\i\p
.context FOR
.context @FOR
:nFOR...NEXT Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Repeats a block of statements a specified number of times.

\bFOR counter = start TO end [STEP increment]\p
    \b[statementblock]\p
\bNEXT [counter [,counter]...]\p

    ş \bcounter\p          A numeric variable used as the loop counter.
    ş \bstart\p and \bend\p    The initial and final values of the counter.
    ş \bincrement\p        The amount the counter is changed each time through
                       the loop.

Example:
    FOR i% = 1 TO 15
        PRINT i%
    NEXT i%
    FOR i% = 7 to -6 STEP -3
        PRINT i%
    NEXT i%

See Also    \i\p\aDO...LOOP\v@DO\v\i\p    \i\p\aEXIT\v@EXIT\v\i\p    \i\p\aWHILE...WEND\v@WHILE\v\i\p
.context GOSUB
.context @GOSUB
.context RETURN
.context @RETURN
:nGOSUB...RETURN Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Branches to and returns from a subroutine.

\bGOSUB line1\p
\b.\p
\b.\p
\b.\p
\bRETURN [line2]\p

    ş \bline1\p    The label or line number of the first line of the subroutine.
    ş \bline2\p    The label or line number where the subroutine returns.

    ş If you don't supply a label or line number for RETURN, the program
      continues execution at the statement following the GOSUB (for
      subroutine calls) or where an event occurred (for event handling).
      See the \i\p\aON\v@ON\v\i\p keyword for information about event-handling statements.
    ş SUB and CALL statements provide a better alternative to GOSUB
      subroutines.

Example:
    FOR i% = 1 TO 20
        GOSUB Square
    NEXT i%
    END

    Square:
    PRINT i%, i% * i%
    RETURN

See Also    \i\p\aCALL\v@CALL\v\i\p    \i\p\aON Keyword\v@ON\v\i\p    \i\p\aON...GOSUB\v@ONGO\v\i\p    \i\p\aSUB\v@SUB\v\i\p
.context GOTO
.context @GOTO
:nGOTO Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Branches to a specified line.

\bGOTO line\p

    ş \bline\p    The label or number of the line to execute next.

    ş DO...LOOP, SELECT CASE, IF...THEN...ELSE, SUB, and FUNCTION provide
      better ways to control the flow of your program.
    ş GOTO is also used as a keyword in the ON ERROR statement.

\i\p\aExample\v@errhand.ex\v\i\p

See Also    \i\p\aDO...LOOP\v@DO\v\i\p    \i\p\aFUNCTION\v@FUNCTION\v\i\p     \i\p\aIF...THEN...ELSE\v@IF\v\i\p
            \i\p\aON ERROR\v@onerr\v\i\p     \i\p\aON...GOTO\v@ongo\v\i\p    \i\p\aSELECT CASE\v@SELECT\v\i\p    \i\p\aSUB\v@SUB\v\i\p
.context THEN
.context @THEN
.context ELSE
.context @ELSE
.context ELSEIF
.context @ELSEIF
.context ENDIF
.context @ENDIF
.context IF
.context @IF
:nIF...THEN...ELSE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Executes a statement or statement block depending on specified conditions.

\bIF condition1 THEN\p
    \b[statementblock-1]\p
\b[ELSEIF condition2 THEN\p
    \b[statementblock-2]]...\p
\b[ELSE\p
    \b[statementblock-n]]\p
\bEND IF\p

\bIF condition THEN statements [ELSE statements]\p

    ş \bcondition1\p          Any expression that can be evaluated as
      \bcondition2\p          true (nonzero) or false (zero).
    ş \bstatementblock-1\p    One or more statements on one or more lines.
      \bstatementblock-2\p
      \bstatementblock-n\p
    ş \bstatements\p          One or more statements, separated by colons.

Example:
    INPUT "1 or 2? ", i%
    IF i% = 1 OR i% = 2 THEN
        PRINT "OK"
    ELSE
        PRINT "Out of range"
    END IF

See Also    \i\p\aON...GOSUB\v@ongo\v\i\p    \i\p\aON...GOTO\v@ongo\v\i\p    \i\p\aSELECT CASE\v@IS\v\i\p
.context @ongo
.context .ongo
:nON...GOSUB, ON...GOTO Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Branch to one of several locations, depending on the value of an expression.

\bON expression% GOSUB line-list\p
\bON expression% GOTO line-list\p

    ş \bexpression%\p    An expression in the range 0 through 255.
    ş \bline-list\p      A set of labels or line numbers. If the value of the
                     expression is 1, the program branches to the first line
                     in the list; if the expression is 2, it branches to the
                     second line, and so on.

    ş SELECT CASE provides a better way to perform multiple branching.

Example:
    FOR i% = 1 TO 2
        ON i% GOSUB One, Two
    NEXT i%
    END

    One: PRINT "One"
    RETURN
    Two: PRINT "Two"
    RETURN

See Also    \i\p\aON Keyword\v@ON\v\i\p    \i\p\aSELECT CASE\v@SELECT\v\i\p
.context RUN
.context @RUN
:nRUN Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Runs the current program or a specified program.

\bRUN [{linenumber | file$}]\p

    ş \blinenumber\p    The line number in the current program where execution
                    should begin. If no line number is specified, execution
                    begins at the first executable line.
    ş \bfile$\p 	The name of a Basic source file. QBasic assumes
                    a .BAS extension.

    ş RUN closes all files and clears program memory before loading a
      program. Use the CHAIN statement to run a program without closing
      open files.

Example:
    'Assumes the program TEST.BAS is in a \\DOS directory.
    RUN "C:\\DOS\\TEST.BAS"

See Also    \i\p\aCHAIN\v@CHAIN\v\i\p
.context SELECT
.context @SELECT
.context CASE
.context @CASE
.context IS
.context @IS
:nSELECT CASE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Executes one of several statement blocks depending on the value of an
expression.

\bSELECT CASE testexpression\p
\bCASE expressionlist1\p
  \b[statementblock-1]\p
\b[CASE expressionlist2\p
  \b[statementblock-2]]...\p
\b[CASE ELSE\p
  \b[statementblock-n]]\p
\bEND SELECT\p

    ş \btestexpression\p      Any numeric or string expression.
    ş \bexpressionlist1\p     One or more expressions to match testexpression.
      \bexpressionlist2\p     The IS keyword must precede any relational operators
                          in an expression.
    ş \bstatementblock-1\p    One or more statements on one or more lines.
      \bstatementblock-2\p
      \bstatementblock-n\p

    ş The expressionlist arguments can have any of these forms or a
      combination of them, separated by commas:

      \bexpression[,expression]...\p
      \bexpression TO expression\p
      \bIS relational-operator expression\p

          \bexpression\p             Any numeric or string expression compatible
                                 with testexpression.
          \brelational-operator\p    One of the following relational operators:
                                   <, <=, >, >=, <>, or =.

Example:
    INPUT "Enter acceptable level of risk (1-5): ", Total
    SELECT CASE Total

        CASE IS >= 5
            PRINT "Maximum risk and potential return."
            PRINT "Choose stock investment plan."

        CASE 2 TO 4
            PRINT "Moderate to high risk and potential return."
            PRINT "Choose mutual fund or corporate bonds."

        CASE 1
            PRINT "No risk, low return."
            PRINT "Choose IRA."

    END SELECT

See Also    \i\p\aIF...THEN...ELSE\v@IF\v\i\p
.context SLEEP
.context @SLEEP
:nSLEEP Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Suspends program execution.

\bSLEEP [seconds&]\p

    ş \bseconds&\p    Number of seconds to suspend the program.

    ş If seconds& is 0 or is omitted, the program is suspended until a key
      is pressed or a trapped event occurs.

Example:
    PRINT "Taking a 10-second nap..."
    SLEEP 10
    PRINT "Wake up!"

See Also    \i\p\aWAIT\v@WAIT\v\i\p
.context STOP
.context @STOP
:nSTOP Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Halts a program.

\bSTOP\p

    ş The STOP keyword also suspends trapping of events in these statements:

      \i\p\aCOM, ON COM\v@COM\v\i\p      \i\p\aKEY, ON KEY\v@KETV\v\i\p         \i\p\aPEN, ON PEN\v@PEN\v\i\p
      \i\p\aPLAY, ON PLAY\v@PLAYEV\v\i\p    \i\p\aSTRIG, ON STRIG\v@STRIG\v\i\p     \i\p\aTIMER, ON TIMER\v@TIMER\v\i\p

Example:
    FOR i% = 1 TO 10
        PRINT i%
        IF i% = 5 THEN STOP     'STOP pauses; F5 Continues.
    NEXT i%

See Also     \i\p\aEND\v@END\v\i\p    \i\p\aSYSTEM\v@SYSTEM\v\i\p
.context SYSTEM
.context @SYSTEM
:nSYSTEM Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Closes all open files and returns control to the operating system.

\bSYSTEM\p

See Also    \i\p\aEND\v@END\v\i\p    \i\p\aSTOP\v@STOP\v\i\p
.context TRON
.context @TRON
.context TROFF
.context @TROFF
:nTRON, TROFF Statements
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
TRON and TROFF enable and disable tracing of program statements.

\bTRON\p
\bTROFF\p

    ş QBasic's debugging features make these statements unnecessary.

See Also    \i\p\aRun and Debug Keys\v@dk\v\i\p
.context wend
.context @wend
.context WHILE
.context @WHILE
:nWHILE...WEND Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Executes a series of statements as long as a specified condition is true.

\bWHILE condition\p
\b.\p
\b.\p
\b.\p
\bWEND\p

    ş \bcondition\p    A numeric expression that Basic evaluates as true
                   (nonzero) or false (zero).

    ş DO...LOOP provides a better way to execute statements in a
      program loop.

See Also    \i\p\aDO...LOOP\v@DO\v\i\p    \i\p\aFOR...NEXT\v@FOR\v\i\p
.comment ******************************************************************
.comment * Boolean Operators
.comment ******************************************************************
.context AND
.context @AND
.context EQV
.context @EQV
.context IMP
.context @IMP
.context NOT
.context @NOT
.context OR
.context @OR
.context XOR
.context @XOR
:nBoolean Operators
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Boolean operators perform bit manipulations, Boolean operations, or tests on
multiple relations. They return a true (nonzero) or false (zero) value to be
used in making a decision.

\bresult = expression1 boolean-operator expression2\p

    ş \bboolean-operator\p    Any of the following Boolean operators:

        NOT                 Bit-wise complement
        AND                 Conjunction
        OR                  Disjunction (inclusive "or")
        XOR                 Exclusive "or"
        EQV                 Equivalence
        IMP                 Implication

    ş Each operator returns results as indicated in the following truth
      table. T is true (nonzero); F is false (zero):

        Expression1  Expression2  NOT  AND  OR   XOR  EQV  IMP
        ÍÍÍÍÍÍÍÍÍÍÍ  ÍÍÍÍÍÍÍÍÍÍÍ  ÍÍÍ  ÍÍÍ  ÍÍÍ  ÍÍÍ  ÍÍÍ  ÍÍÍ
        T            T            F    T    T    F    T    T
        T            F            F    F    T    T    F    F
        F            T            T    F    T    T    F    T
        F            F            T    F    F    F    T    T

    ş Boolean operations are performed after arithmetic and relational
      operations in order of precedence.
    ş Expressions are converted to integers or long integers before a
      Boolean operation is performed.
    ş If the expressions evaluate to 0 or -1, a Boolean operation returns
      0 or -1 as the result. Because Boolean operators do bit-wise
      calculations, using values other than 0 for false and -1 for true may
      produce unexpected results.
.comment ******************************************************************
.comment * Keywords
.comment ******************************************************************
.context NEXT
.context @NEXT
:nNEXT Keyword
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Increments and tests the counter in a FOR...NEXT loop or, when used with
RESUME, continues execution from an error-trapping handler.

See Also    \i\p\aFOR...NEXT\v@FOR\v\i\p    \i\p\aRESUME\v@RESUME\v\i\p
.context STEP
.context @STEP
:nSTEP Keyword
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
In a FOR...NEXT loop, specifies how much to increase the counter in each
iteration. In graphics statements, specifies that pixel coordinates are
relative to the current graphics cursor position.

See Also    \i\p\aCIRCLE\v@CIRCLE\v\i\p    \i\p\aFOR...NEXT\v@FOR\v\i\p    \i\p\aGET, PUT\v@ggx\v\i\p    \i\p\aLINE\v@LINE\v\i\p
            \i\p\aPAINT\v@PAINT\v\i\p     \i\p\aPRESET, PSET\v@PRESET\v\i\p
.context TO
.context @TO
:nTO Keyword
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Specifies ranges for:

    ş A CASE clause of a SELECT CASE statement.
    ş A loop counter in a FOR...NEXT loop.
    ş Records to lock or unlock in a LOCK...UNLOCK statement.
    ş Lower and upper bounds in a DIM or REDIM statement.

See Also    \i\p\aDIM, REDIM\v@DIM\v\i\p    \i\p\aFOR...NEXT\v@FOR\v\i\p    \i\p\aLOCK, UNLOCK\v@LOCK\v\i\p    \i\p\aSELECT CASE\v@SELECT\v\i\p
.comment ******************************************************************
.comment *  Memory Family - QBasic                                        *
.comment ******************************************************************
.comment * 1/10/90 Cleaned comments.
.comment *    -- JeffWe
.comment ******************************************************************
.context CLEAR
.context @CLEAR
:nCLEAR Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Closes all files, releases file buffers, clears all common variables, sets
numeric variables and arrays to zero, sets string variables to null, and
initializes the stack. Optionally, CLEAR also changes the size of the stack.

\bCLEAR [,,stack&]\p

    ş \bstack&\p    Sets the size (in bytes) of stack space for your program.

Example:
    CLEAR ,,2000

See Also    \i\p\aERASE\v@ERASE\v\i\p
.context SEG
.context @SEG
:nDEF SEG Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Sets the current segment address.

\bDEF SEG [=address]\p

    ş \baddress\p    A segment address used by BLOAD, BSAVE, CALL ABSOLUTE,
                 PEEK, or POKE; a value in the range 0 through 65,535. If
                 address is omitted, DEF SEG resets the current segment
                 address to the default data segment.

Example:
    DEF SEG = 0
    Status% = PEEK(&H417)              'Read keyboard status.
    POKE &H417, (Status% XOR &H40)     'Change Caps Lock state, bit 6.

See Also    \i\p\aBSAVE, BLOAD\v@BLOAD\v\i\p    \i\p\aCALL ABSOLUTE\v@ABSOLUTE\v\i\p    \i\p\aPEEK, POKE\v@PEEK\v\i\p
.context FRE
.context @FRE
:nFRE Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the amount (in bytes) of available or unused memory.

\bFRE(numeric-expression)\p
\bFRE(stringexpression$)\p

    ş \bnumeric-expression\p    A value that specifies the type of memory:

                            Value               FRE returns
                            ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                            -1                  The size of the largest array
                                                (nonstring) you can create
                            -2                  The unused stack space
                            Any other number    The available string space

    ş \bstringexpression$\p     Any string expression. FRE compacts the free
                            string space into a single block, then returns
                            the amount of available string space.

Example:
    PRINT "String Space", FRE("")
    PRINT "Unused Stack Space", FRE(-2)
    PRINT "Array Space", FRE(-1)
.context HEX$
.context @HEX$
.context OCT$
.context @OCT$
:nHEX$, OCT$ Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
HEX$ returns a hexadecimal string representation of a number.
OCT$ returns an octal string representation of a number.

\bHEX$(numeric-expression&)\p
\bOCT$(numeric-expression&)\p

    ş \bnumeric-expression&\p    Any numeric expression. The expression is
                             rounded to an integer or long integer before it
                             is evaluated.

Example:
    INPUT x
    a$ = HEX$ (x)
    b$ = OCT$ (x)
    PRINT x; "decimal is "; a$; " hexadecimal and "; b$; " in octal."
.context INSTR
.context @INSTR
:nINSTR Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the position of the first occurrence of a string in another string.

\bINSTR([start%,]stringexpression1$,stringexpression2$)\p

    ş \bstart%\p                Sets the character position where the search
                            begins. If start% is omitted, INSTR starts at
                            position 1.
    ş \bstringexpression1$\p    The string to search.
    ş \bstringexpression2$\p    The string to look for.

Example:
    a$ = "Microsoft QBasic"
    PRINT "String position ="; INSTR(1, a$, "QBasic")

See Also    \i\p\aLEFT$, RIGHT$\v@LEFT$\v\i\p    \i\p\aLEN\v@LEN\v\i\p    \i\p\aMID$\v@MID$\v\i\p
.context LCASE$
.context @LCASE$
.context UCASE$
.context @UCASE$
:nLCASE$, UCASE$ Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Convert strings to all lowercase or all uppercase letters.

\bLCASE$(stringexpression$)\p
\bUCASE$(stringexpression$)\p

    ş \bstringexpression$\p    Any string expression.

Example:
    Test$ = "THE string"
    PRINT Test$
    PRINT LCASE$(Test$); " in lowercase"
    PRINT UCASE$(Test$); " IN UPPERCASE"
.context LEFT$
.context @LEFT$
.context RIGHT$
.context @RIGHT$
:nLEFT$, RIGHT$ Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return a specified number of leftmost or rightmost characters in a string.

\bLEFT$(stringexpression$,n%)\p
\bRIGHT$(stringexpression$,n%)\p

    ş \bstringexpression$\p    Any string expression.
    ş \bn%\p                   The number of characters to return, beginning
                           with the leftmost or rightmost string character.

Example:
    a$ = "Microsoft QBasic"
    PRINT LEFT$(a$, 5)     'Output is:  Micro
    PRINT RIGHT$(a$, 5)    'Output is:  Basic

See Also    \i\p\aMID$\v@MID$\v\i\p
.context LEN
.context @LEN
:nLEN Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns the number of characters in a string or the number of bytes
required to store a variable.

\bLEN(stringexpression$)\p
\bLEN(variable)\p

    ş \bstringexpression$\p    Any string expression.
    ş \bvariable\p             Any nonstring variable.

Example:
    a$ = "Microsoft QBasic"
    PRINT LEN(a$)

See Also    \i\p\aOPEN\v@OPEN\v\i\p
.context LTRIM$
.context @LTRIM$
.context RTRIM$
.context @RTRIM$
:nLTRIM$, RTRIM$ Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Remove leading and trailing spaces from a string.

\bLTRIM$(stringexpression$)\p
\bRTRIM$(stringexpression$)\p

    ş \bstringexpression$\p    Any string expression.

Example:
    a$ = "    Basic    "
    PRINT "*" + a$ + "*"	    'Output is:  *    Basic    *
    PRINT "*" + LTRIM$(a$) + "*"    'Output is:  *Basic    *
    PRINT "*" + RTRIM$(a$) + "*"    'Output is:  *    Basic*
.context MID$
.context @MID$
:nMID$ Function and Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
The MID$ function returns part of a string (a substring).
The MID$ statement replaces part of a string variable with another string.

\bMID$(stringexpression$,start%[,length%])\p
\bMID$(stringvariable$,start%[,length%])=stringexpression$\p

    ş \bstringexpression$\p    The string from which the MID$ function returns
                           a substring, or the replacement string used by the
                           MID$ statement. It can be any string expression.
    ş \bstart%\p               The position of the first character in the
                           substring being returned or replaced.
    ş \blength%\p              The number of characters in the substring. If the
                           length is omitted, MID$ returns or replaces all
                           characters to the right of the start position.
    ş \bstringvariable$\p      The string variable being modified by the MID$
                           statement.

Example:
    a$ = "Where is Paris?"
    PRINT MID$(a$, 10, 5)       'Output is:  Paris
    Text$ = "Paris, France"
    PRINT Text$                 'Output is:  Paris, France
    MID$(Text$, 8) = "Texas "
    PRINT Text$                 'Output is:  Paris, Texas

See Also    \i\p\aLEFT$, RIGHT$\v@LEFT$\v\i\p    \i\p\aLEN\v@LEN\v\i\p
.context CVI
.context @CVI
.context CVS
.context @CVS
.context CVL
.context @CVL
.context CVD
.context @CVD
.context MKL$
.context @MKL$
.context MKI$
.context @MKI$
.context MKS$
.context @MKS$
.context MKD$
.context @MKD$
:nMKn$, CVn Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
MKI$, MKL$, MKS$, and MKD$ convert numbers to numeric strings that can be
stored in FIELD statement string variables. CVI, CVL, CVS, and CVD convert
those strings back to numbers.

\bMKI$(integer-expression%)\p
\bMKL$(long-integer-expression&)\p
\bMKS$(single-precision-expression!)\p
\bMKD$(double-precision-expression#)\p
\bCVI(2-byte-numeric-string)\p
\bCVL(4-byte-numeric-string)\p
\bCVS(4-byte-numeric-string)\p
\bCVD(8-byte-numeric-string)\p

    Function    Returns             Function    Returns
    ÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    MKI$        A 2-byte string     CVI         An integer
    MKL$        A 4-byte string     CVL         A long integer
    MKS$        A 4-byte string     CVS         A single-precision number
    MKD$        An 8-byte string    CVD         A double-precision number

See Also    \i\p\aFIELD\v@FIELD\v\i\p    \i\p\aMKSMBF$, MKDMBF$, CVSMBF, CVDMBF\v@CVSMBF\v\i\p
.context MKDMBF$
.context @MKDMBF$
.context MKSMBF$
.context @MKSMBF$
.context CVDMBF
.context @CVDMBF
.context CVSMBF
.context @CVSMBF
:nMKSMBF$, MKDMBF$, CVSMBF, CVDMBF Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
MKSMBF$ and MKDMBF$ convert IEEE-format numbers to Microsoft-Binary-format
numeric strings that can be stored in FIELD statement string variables.
CVSMBF and CVDMBF convert those strings back to IEEE-format numbers.

\bMKSMBF$(single-precision-expression!)\p
\bMKDMBF$(double-precision-expression#)\p
\bCVSMBF (4-byte-numeric-string)\p
\bCVDMBF (8-byte-numeric-string)\p

    Function    Returns
    ÍÍÍÍÍÍÍÍ    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    MKSMBF$     A 4-byte string containing a Microsoft-Binary-format number
    MKDMBF$     An 8-byte string containing a Microsoft-Binary-format number
    CVSMBF      A single-precision number in IEEE format
    CVDMBF      A double-precision number in IEEE format

    ş These functions are useful for maintaining data files created with
      older versions of Basic.

Example:
    TYPE Buffer
        SngNum AS STRING * 4
        DblNum AS STRING * 8
    END TYPE
    DIM RecBuffer AS Buffer
    OPEN "TESTDAT.DAT" FOR RANDOM AS #1 LEN = 12
    SNum = 98.9
    DNum = 645.3235622#
    RecBuffer.SngNum = MKSMBF$(SNum)
    RecBuffer.DblNum = MKDMBF$(DNum)
    PUT #1, 1, RecBuffer
    GET #1, 1, RecBuffer
    CLOSE #1
    PRINT CVSMBF(RecBuffer.SngNum), CVDMBF(RecBuffer.DblNum)

See Also    \i\p\aFIELD\v@FIELD\v\i\p    \i\p\aMKn$, CVn\v@CVS\v\i\p
.context PEEK
.context @PEEK
.context POKE
.context @POKE
:nPEEK Function, POKE Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
PEEK returns a byte value stored at a specified memory location.
POKE writes a byte value to a specified memory location.

\bPEEK(address)\p
\bPOKE address,byte%\p

    ş \baddress\p    A byte position relative to the current segment address
                 set by DEF SEG; a value in the range 0 through 65,535.
    ş \bbyte%\p      A byte value to write to the specified memory location;
                 a value in the range 0 through 255.

Example:
    DEF SEG = 0
    Status% = PEEK(&H417)              'Read keyboard status.
    POKE &H417, (Status% XOR &H40)     'Change Caps Lock state, bit 6.

See Also    \i\p\aDEF SEG\v@SEG\v\i\p
.context SPACE$
.context @SPACE$
:nSPACE$ Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns a string of spaces.

\bSPACE$(n%)\p

    ş \bn%\p    The number of spaces you want in the string.

Example:
    FOR i% = 1 TO 5
        x$ = SPACE$ (i%)
        PRINT x$; i%
    NEXT i%

See Also    \i\p\aSPC\v@SPC\v\i\p    \i\p\aSTRING$\v@STRING$\v\i\p
.context STR$
.context @STR$
.context VAL
.context @VAL
:nSTR$, VAL Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
STR$ returns a string representation of a number.
VAL converts a string representation of a number to a number.

\bSTR$(numeric-expression)\p
\bVAL(stringexpression$)\p

    ş \bnumeric-expression\p    Any numeric expression.
    ş \bstringexpression$\p     A string representation of a number.

Example:
    PRINT "Decimal 65 is represented in hexadecimal as ";
    PRINT "&H" + LTRIM$(STR$(41))
    PRINT VAL(RIGHT$("Microsoft 1990", 4))
.context STRING$
.context @STRING$
:nSTRING$ Function
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns a string of a specified length made up of a repeating character.

\bSTRING$(length%,{ascii-code% | stringexpression$})\p

    ş \blength%\p              The length of the string.
    ş \bascii-code%\p          The ASCII code of the repeating character.
    ş \bstringexpression$\p    Any string expression. STRING$ fills the string
                           with the first character in stringexpression$.

Example:
    PRINT STRING$(5, "-");
    PRINT "Hello";
    PRINT STRING$(5, "-")

See Also    \i\p\aASCII Character Codes\v@ac\v\i\p
.context VARSEG
.context @VARSEG
.context VARPTR
.context @VARPTR
:nVARPTR, VARSEG Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
VARPTR returns the offset address of a variable.
VARSEG returns the segment address of a variable.

\bVARPTR(variablename)\p
\bVARSEG(variablename)\p

    ş \bvariablename\p	  Any Basic variable.

See Also    \i\p\aCALL ABSOLUTE\v@ABSOLUTE\v\i\p    \i\p\aDEF SEG\v@SEG\v\i\p    \i\p\aPEEK, POKE\v@PEEK\v\i\p    \i\p\aVARPTR$\v@VARPTR$\v\i\p
.context VARPTR$
.context @VARPTR$
:nVARPTR$ Function
  \i\p\aContents\v@helpTableId\v\i\p	\i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Returns a string representation of a variable's address for use in DRAW and
PLAY statements.

\bVARPTR$(commandstring$)\p

    ş \bcommandstring$\p    A string variable containing DRAW or PLAY commands.

Example:
    Scale$ = "CDEFGAB"
    PLAY "L16"
    FOR i% = 0 TO 6
        PLAY "O" + STR$(i%)
        PLAY "X" + VARPTR$(Scale$)
    NEXT i%

See Also   \i\p\aDRAW\v@DRAW\v\i\p   \i\p\aPLAY (Music)\v@PLAY\v\i\p    \i\p\aVARPTR, VARSEG\v@VARPTR\v\i\p
.comment ******************************************************************
.comment *  Error Trapping Family - QBasic                                *
.comment ******************************************************************
.comment * 01/09/91 Cleaned up comments.
.comment *  -- JeffWe
.comment ******************************************************************
.context @ERL
.context @ERR
.context ERL
.context ERR
:nERR, ERL Functions
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
ERR returns the run-time error code for the most recent error.
ERL returns the line number where the error occurred, or the closest line
number before the line where the error occurred.

\bERR\p
\bERL\p

    ş ERL does not return line labels. If there are no line numbers in the
      program, ERL returns 0.

\i\p\aExample\v@errhand.ex\v\i\p

See Also    \i\p\aERDEV, ERDEV$\v@ERDEV\v\i\p    \i\p\aERROR\v@ERROR\v\i\p    \i\p\aON ERROR\v@onerr\v\i\p    \i\p\aRESUME\v@RESUME\v\i\p
            \i\p\aRun-Time Error Codes\v@rtect\v\i\p
.context ERROR
.context @ERROR
:nERROR Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Simulates an occurrence of a Basic error or a user-defined error.

\bERROR expression%\p

    ş \bexpression%\p	 The error code of a Basic or user-defined error; a
                     value in the range 1 through 255. To define your own
		     error, use a value that isn't listed in the Basic
                     \i\p\aRun-Time Error Codes\v@rtect\v\i\p table.

\i\p\aExample\v@errhand.ex\v\i\p

See Also    \i\p\aERDEV, ERDEV$\v@ERDEV\v\i\p    \i\p\aERR, ERL\v@ERR\v\i\p    \i\p\aON ERROR\v@onerr\v\i\p    \i\p\aRESUME\v@RESUME\v\i\p
.context .onerr
.context @onerr
:nON ERROR Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Enables error handling and, when a run-time error occurs, directs your
program to either branch to an error-handling routine or resume execution.

\bON ERROR {GOTO line | RESUME NEXT}\p

    ş \bGOTO line\p      Branches to the first line of the error-handling
                     routine, specified by a label or line number. To
                     disable error handling, specify GOTO 0.
    ş \bRESUME NEXT\p    Resumes execution with the statement following the
                     statement that caused the run-time error. Use the ERR
                     function to obtain the error code for the error.

    ş If ON ERROR isn't used, any run-time error ends your program.

\i\p\aExample\v@errhand.ex\v\i\p

See Also    \i\p\aERDEV, ERDEV$\v@ERDEV\v\i\p    \i\p\aERR, ERL\v@ERR\v\i\p    \i\p\aERROR\v@ERROR\v\i\p    \i\p\aGOTO\v@GOTO\v\i\p    \i\p\aRESUME\v@RESUME\v\i\p
.context @RESUME
.context RESUME
:nRESUME Statement
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Resumes program execution after an error-handling routine.

\bRESUME [{line | NEXT}]\p

    ş \bline\p    The label or number of the line where execution resumes. If
              line is 0 or omitted, execution resumes with the statement
              that caused the error.
    ş \bNEXT\p    Resumes execution at the statement following the statement
              that caused the error.

\i\p\aExample\v@errhand.ex\v\i\p

See Also    \i\p\aERROR\v@ERROR\v\i\p    \i\p\aON ERROR\v@onerr\v\i\p
.context errhand.ex
.context @errhand.ex
:nError-Handling Example
  \i\p\aContents\v@helpTableId\v\i\p  \i\p\aIndex\v@helpIndexId\v\i\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
'Illustrates ERDEV, ERDEV$, ERL, ERR, ERROR, ON ERROR, and RESUME.
   ON ERROR GOTO Handler
10 CHDIR "a:\\"                'Causes ERR 71 "Disk not ready"
                              'if no disk in Drive A.
20 y% = 0
30 x% = 5 / y%                'ERR 11 "Division by zero."
40 PRINT "x% ="; x%
50 ERROR 57                   'ERR 57 "Device I/O error."

Handler:
  PRINT
  PRINT "Error "; ERR; " on line "; ERL
  SELECT CASE ERR
    CASE 71
      PRINT "Using device "; ERDEV$; " device error code = "; ERDEV
      RESUME NEXT
    CASE 11
      INPUT "What value do you want to divide by"; y%
      RESUME                  'Retry line 30 with new value of y%.
    CASE ELSE
      PRINT "Unexpected error, ending program."
      END
  END SELECT
.comment ******************************************************************
.comment *  Index file - QBasic                                           *
.comment ******************************************************************
.comment * 1/10/91 Cleaned up comments.
.comment *   -- JeffWe
.comment ******************************************************************
.context @helpIndexId
.context helpIndexId
.context @a
:nQBasic Online Help Index
  \i\p\aContents\v@helpTableId\v\i\p  \bIndex\p  \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
To get help on a QBasic keyword in the list below:
    1. Press the key of the first letter of the keyword.
    2. Use the direction keys to move the cursor to the keyword.
    3. Press F1 to display the help text in the Help window.
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ A º
                                                                  ÈÍÍÍ¼
  \aABS Function\v@ABS\v                       \aAPPEND Keyword\v@APPEND\v
  \aABSOLUTE Keyword\v@ABSOLUTE\v                   \aAS Keyword\v@AS\v
  \aACCESS Keyword\v@ACCESS\v                     \aASC Function\v@ASC\v
  \aAND Operator\v@AND\v                       \aATN Function\v@ATN\v
  \aANY Keyword\v@ANY\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ B º
                                                                  ÈÍÍÍ¼
  \aBASE Keyword\v@BASE\v                       \aBLOAD Statement\v@BLOAD\v
  \aBasic Character Set\v@fun.character.set\v                \aBoolean Operators\v@AND\v
  \aBEEP Statement\v@BEEP\v                     \aBSAVE Statement\v@BSAVE\v
  \aBINARY Keyword\v@BINARY\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ C º
                                                                  ÈÍÍÍ¼
  \aCALL Statement\v@CALL\v                     \aCOLOR Statement\v@COLOR\v
  \aCALL ABSOLUTE Statement\v@ABSOLUTE\v            \aCOM Statement\v@COM\v
  \aCASE Keyword\v@SELECT\v                       \aCOMMON Statement\v@COMMON\v
  \aCDBL Function\v@CDBL\v                      \aCONST Statement\v@CONST\v
  \aCHAIN Statement\v@CHAIN\v                    \aCOS Function\v@COS\v
  \aCHDIR Statement\v@CHDIR\v                    \aCSNG Function\v@CSNG\v
  \aCHR$ Function\v@CHR$\v                      \aCSRLIN Function\v@CSRLIN\v
  \aCINT Function\v@CINT\v                      \aCVD Function\v@CVD\v
  \aCIRCLE Statement\v@CIRCLE\v                   \aCVDMBF Function\v@CVDMBF\v
  \aCLEAR Statement\v@CLEAR\v                    \aCVI Function\v@CVI\v
  \aCLNG Function\v@CLNG\v                      \aCVL Function\v@CVL\v
  \aCLOSE Statement\v@CLOSE\v                    \aCVS Function\v@CVS\v
  \aCLS Statement\v@CLS\v                      \aCVSMBF Function\v@CVSMBF\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ D º
                                                                  ÈÍÍÍ¼
  \aDATA Statement\v@DATA\v                     \aDEFLNG Statement\v@DEFLNG\v
  \aData Type Keywords\v@INTEGER\v                 \aDEFSNG Statement\v@DEFSNG\v\p
  \aDATE$ Function\v@datef\v                     \aDEFSTR Statement\v@DEFSTR\v
  \aDATE$ Statement\v@DATE$\v                    \aDIM Statement\v@DIM\v
  \aDECLARE Statement\v@DECLARE\v                  \aDO...LOOP Statement\v@DO\v\p
  \aDEF FN Statement\v@DEF\v                   \aDOUBLE Keyword\v@DOUBLE\v
  \aDEF SEG Statement\v@SEG\v                  \aDRAW Statement\v@DRAW\v
  \aDEFDBL Statement\v@DEFDBL\v                   \a$DYNAMIC Metacommand\v@$DYNAMIC\v
  \aDEFINT Statement\v@DEFINT\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ E º
                                                                  ÈÍÍÍ¼
  \aELSE Keyword\v@IF\v                       \aERDEV Function\v@ERDEV\v
  \aELSEIF Keyword\v@IF\v                     \aERDEV$ Function\v@ERDEV$\v\p
  \aEND Statement\v@END\v                      \aERL Function\v@ERL\v\p
  \aENVIRON Statement\v@ENVIRON\v                  \aERR Function\v@ERR\v
  \aENVIRON$ Function\v@ENVIRON$\v                  \aERROR Statement\v@ERROR\v
  \aEOF Function\v@EOF\v                       \aEXIT Statement\v@EXIT\v
  \aEQV Operator\v@EQV\v                       \aEXP Function\v@EXP\v
  \aERASE Statement\v@ERASE\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ F º
                                                                  ÈÍÍÍ¼
  \aFIELD Statement\v@FIELD\v                    \aFOR...NEXT Statement\v@FOR\v
  \aFILEATTR Function\v@FILEATTR\v                  \aFRE Function\v@FRE\v
  \aFILES Statement\v@FILES\v                    \aFREEFILE Function\v@FREEFILE\v
  \aFIX Function\v@FIX\v                       \aFUNCTION Statement\v@FUNCTION\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ G º
                                                                  ÈÍÍÍ¼
  \aGET (File I/O) Statement\v@GET\v           \aGOSUB Statement\v@GOSUB\v
  \aGET (Graphics) Statement\v@ggx\v           \aGOTO Statement\v@GOTO\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ H º
                                                                  ÈÍÍÍ¼
  \aHEX$ Function\v@HEX$\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ I º
                                                                  ÈÍÍÍ¼
  \aIF...THEN...ELSE Statement\v@IF\v         \aINSTR Function\v@INSTR\v
  \aIMP Operator\v@IMP\v                       \aINT Function\v@INT\v
  \aINKEY$ Function\v@INKEY$\v                    \aINTEGER Keyword\v@INTEGER\v
  \aINP Function\v@INP\v                       \aIOCTL Statement\v@IOCTL\v
  \aINPUT Statement\v@INPUT\v                    \aIOCTL$ Function\v@IOCTL$\v
  \aINPUT$ Function\v@INPUT$\v                    \aIS Keyword\v@IS\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ K º
                                                                  ÈÍÍÍ¼
  \aKEY (Assignment) Statement\v@KEY\v         \aKILL Statement\v@KILL\v
  \aKEY (Event Trapping) Statement\v@ketv\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ L º
                                                                  ÈÍÍÍ¼
  \aLBOUND Function\v@LBOUND\v                    \aLOCK...UNLOCK Statements\v@LOCK\v\p
  \aLCASE$ Function\v@LCASE$\v                    \aLOF Function\v@LOF\v\p
  \aLEFT$ Function\v@LEFT$\v                     \aLOG Function\v@LOG\v\p
  \aLEN Function\v@LEN\v                       \aLONG Keyword\v@LONG\v\p
  \aLET Statement\v@LET\v                      \aLOOP Keyword\v@LOOP\v\p
  \aLINE (Graphics) Statement\v@LINE\v          \aLPOS Function\v@LPOS\v\p
  \aLINE INPUT Statement\v@INPUT\v               \aLPRINT Statement\v@LPRINT\v\p
  \aLIST Keyword\v@LIST\v                       \aLPRINT USING Statement\v@lprintu\v
  \aLOC Function\v@LOC\v                       \aLSET Statement\v@LSET\v\p
  \aLOCATE Statement\v@LOCATE\v                   \aLTRIM$ Function\v@LTRIM$\v\p
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ M º
                                                                  ÈÍÍÍ¼
  \aMID$ Function\v@MID$\v                      \aMKI$ Function\v@MKI$\v
  \aMID$ Statement\v@MID$\v                     \aMKL$ Function\v@MKL$\v
  \aMKD$ Function\v@MKD$\v                      \aMKS$ Function\v@MKS$\v
  \aMKDIR Statement\v@MKDIR\v                    \aMKSMBF$ Function\v@MKSMBF$\v
  \aMKDMBF$ Function\v@MKDMBF$\v                   \aMOD Operator\v@MOD\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ N º
                                                                  ÈÍÍÍ¼
  \aNAME Statement\v@NAME\v                     \aNOT Operator\v@NOT\v
  \aNEXT Keyword\v@NEXT\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ O º
                                                                  ÈÍÍÍ¼
  \aOCT$ Function\v@HEX$\v                      \aON TIMER Statement\v@TIMER\v
  \aOFF Keyword\v@OFF\v                        \aON...GOSUB Statement\v@ongo\v\p
  \aON COM Statement\v@COM\v                   \aON...GOTO Statement\v@ongo\v\p
  \aON ERROR Statement\v@onerr\v                 \aOPEN Statement\v@OPEN\v\p
  \aON Keyword\v@ON\v                         \aOPEN COM Statement\v@opcom\v
  \aON KEY Statement\v@ketv\v                   \aOPTION BASE Statement\v@BASE\v\p
  \aON PEN Statement\v@PEN\v                   \aOR Operator\v@OR\v
  \aON PLAY Statement\v@playev\v                  \aOUT Statement\v@OUT\v
  \aON STRIG Statement\v@STRIG\v                 \aOUTPUT Keyword\v@OUTPUT\v\p
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ P º
                                                                  ÈÍÍÍ¼
  \aPAINT Statement\v@PAINT\v                    \aPOINT Function\v@POINT\v
  \aPALETTE Statements\v@PALETTE\v                 \aPOKE Statement\v@POKE\v
  \aPCOPY Statement\v@PCOPY\v                    \aPOS Function\v@POS\v
  \aPEEK Function\v@PEEK\v                      \aPRESET Statement\v@PRESET\v
  \aPEN Function\v@penf\v                       \aPRINT Statement\v@PRINT\v
  \aPEN Statement\v@PEN\v                      \aPRINT USING Statement\v@zpu\v
  \aPLAY Function\v@playf\v                      \aPSET Statement\v@PSET\v
  \aPLAY (Music) Statement\v@PLAY\v             \aPUT (File I/O) Statement\v@PUT\v
  \aPLAY (Event Trapping) Statements\v@playev\v   \aPUT (Graphics) Statement\v@pgfx\v
  \aPMAP Function\v@PMAP\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ R º
                                                                  ÈÍÍÍ¼
  \aRANDOM Keyword\v@RANDOM\v                     \aRETURN Statement\v@RETURN\v
  \aRANDOMIZE Statement\v@RANDOMIZE\v                \aRIGHT$ Function\v@RIGHT$\v
  \aREAD Statement\v@READ\v                     \aRMDIR Statement\v@RMDIR\v
  \aREDIM Statement\v@REDIM\v                    \aRND Function\v@RND\v
  \aREM Statement\v@REM\v                      \aRSET Statement\v@RSET\v
  \aRESET Statement\v@RESET\v                    \aRTRIM$ Function\v@RTRIM$\v
  \aRESTORE Statement\v@RESTORE\v                  \aRUN Statement\v@RUN\v
  \aRESUME Statement\v@RESUME\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ S º
                                                                  ÈÍÍÍ¼
  \aSCREEN Function\v@screenf\v                    \aSQR Function\v@SQR\v
  \aSCREEN Statement\v@SCREEN\v                   \aSTATIC Statement\v@STATIC\v
  \aSEEK Function\v@SEEK\v                      \a$STATIC Metacommand\v@$STATIC\v
  \aSEEK Statement\v@SEEK\v                     \aSTEP Keyword\v@STEP\v
  \aSELECT CASE Statement\v@SELECT\v              \aSTICK Function\v@STICK\v
  \aSGN Function\v@SGN\v                       \aSTOP Statement\v@STOP\v
  \aSHARED Statement\v@SHARED\v                   \aSTR$ Function\v@STR$\v
  \aSHELL Statement\v@SHELL\v                    \aSTRIG Function\v@strigf\v
  \aSIN Function\v@SIN\v                       \aSTRIG Statements\v@STRIG\v
  \aSINGLE Keyword\v@SINGLE\v                     \aSTRING Keyword\v@STRING\v
  \aSLEEP Statement\v@SLEEP\v                    \aSTRING$ Function\v@STRING$\v
  \aSOUND Statement\v@SOUND\v                    \aSUB Statement\v@SUB\v
  \aSPACE$ Function\v@SPACE$\v                    \aSWAP Statement\v@SWAP\v
  \aSPC Function\v@SPC\v                       \aSYSTEM Statement\v@SYSTEM\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ T º
                                                                  ÈÍÍÍ¼
  \aTAB Function\v@TAB\v                       \aTIMER Statements\v@TIMER\v
  \aTAN Function\v@TAN\v                       \aTO Keyword\v@TO\v
  \aTHEN Keyword\v@IF\v                       \aTROFF Statement\v@TROFF\v
  \aTIME$ Function\v@tmf\v                     \aTRON Statement\v@TRON\v
  \aTIME$ Statement\v@TIME$\v                    \aTYPE Statement\v@TYPE\v
  \aTIMER Function\v@timerf\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ U º
                                                                  ÈÍÍÍ¼
  \aUBOUND Function\v@UBOUND\v                    \aUNTIL Keyword\v@DO\v
  \aUCASE$ Function\v@UCASE$\v                    \aUSING Keyword\v@USING\v
  \aUNLOCK Statement\v@UNLOCK\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ V º
                                                                  ÈÍÍÍ¼
  \aVAL Function\v@VAL\v                       \aVARSEG Function\v@VARSEG\v
  \aVARPTR Function\v@VARPTR\v                    \aVIEW Statement\v@VIEW\v
  \aVARPTR$ Function\v@VARPTR$\v                   \aVIEW PRINT Statement\v@vupri\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ W º
                                                                  ÈÍÍÍ¼
  \aWAIT Statement\v@WAIT\v                     \aWIDTH Statements\v@WIDTH\v
  \aWEND Keyword\v@WEND\v                       \aWINDOW Statement\v@WINDOW\v
  \aWHILE...WEND Statement\v@WEND\v             \aWRITE Statement\v@WRITE\v
                                                                  ÉÍÍÍ»
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ X º
                                                                  ÈÍÍÍ¼
  \aXOR Operator\v@XOR\v
.comment ==============================================================
.comment QBasic Environment Help
.comment  This file contains Environment Help (for menus,
.comment  dialog boxes, etc.). These are not error messages
.comment ==============================================================
.comment  01/10/90 Cleaned comments.
.comment    -- JeffWe
.comment ==============================================================
.context hidGreetingBox
:nWelcome to QBasic
  ş Press Esc to enter the QBasic programming
    environment.

  ş Press Enter to display the QBasic Survival Guide.
    The Survival Guide shows you how to start using the
    QBasic environment and the QBasic Help system.
.comment ------------------------------------------------
.comment     Dialog Box Help - UIHELPID.H,  900-921
.comment ------------------------------------------------
.context hidFileOpen
:nOpen Dialog
Use to open an existing program file.
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Open ÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                 ³  Type the name of the
³ File Name: ±±±±±±±± ÄÄÄÄÄÄÄÄÄÄÄÄÄ file here if it is in
³                                 ³  the current directory
³ C:\\DOS ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ (shown here), or
³                                 ³
³      Files          Dirs/Drives ³
³ ±±±±±±±±±±±±±±±±    ±±±±±±±±±±± ³  Select a file here,
³ ±±±±±±±±±±±±±±±±    ±±±±±±±±±±± ³  or a directory or
³ ±±±±±±±±±±±±±±±±    ±±±±±±±±±±± ³  drive if the file
³                               ³  is located elsewhere.
³        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÀÄÄÄÄÄÄÄÄÄÄÄÙ
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  Then choose <OK>.

You can also select a new drive and directory by typing
them in the File Name text box.

To browse the contents of other drives and directories,
type a wildcard filename (such as *.BAS) in the File
Name text box, and select a new drive or directory.

Note: To open a file created with GW-BASIC or BASICA, the
      file must be saved from GW-BASIC or BASICA with the
      ,A option.
.context hidFileSave
:nSave As Dialog
Use to save and name the current file.
ÚÄÄÄÄÄÄÄÄÄÄÄÄ Save As ÄÄÄÄÄÄÄÄÄÄÄ¿
³                                ³  Accept this filename or
³ File Name: ±±±±±±±±±±±±±±± ÄÄÄÄÄ type a new name here.
³                                ³
³ C:\\DOS ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ File will be saved in
³                                ³  this directory.
³           Dirs/Drives          ³
³           ±±±±±±±±±±±  ÄÄÄÄÄÄÄÄÄ Use Dirs/Drives to
³           ±±±±±±±±±±±          ³  save to a different
³           ±±±±±±±±±±±          ³  directory or drive.
³                                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  Then choose <OK>.
.context hidFilePrint
:nPrint Dialog
Use to print all or part of a program or Help topic.
Make sure the printer attached to the LPT1 device
on your computer is on and ready to print. Then choose
one of the following options and press Enter:
ÚÄÄÄÄÄÄÄÄ Print ÄÄÄÄÄÄÄÄ¿
³ ± Selected Text Only ÄÄ Prints selected text.
³                       ³
³ ± Current Window ÄÄÄÄÄÄ Prints a procedure or text from
³                       ³  the current window.
³ ± Entire Program ÄÄÄÄÄÄ Prints all of the current
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  program.

The Entire Program option is not available if you select
Print while the cursor is in the Help window.

Tip: Select text in your program or the Help window
     before you choose the Print command. Place the
     cursor at the beginning of the text you want to
     print, press Shift+direction keys until all the text
     is highlighted, then choose the Print command.
.context hidNewProc
:nNew SUB or FUNCTION Dialog
Use to create a new SUB or FUNCTION procedure.
Enter the name of the new procedure (up to 40 characters)
in the text box, then choose <OK>.

Descriptive procedure names help you remember the
procedure's use and minimize the chances of duplicating
the name of another procedure or a variable.
.context hidViewSubs
:nSUBs Command Dialog
Use to edit or delete SUB and FUNCTION procedures.
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ SUBs ÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Choose program item to edit:   ³  Select an item here.
³ ±±±±±±±±±±±±±±±±±±±±±±±±±±±±± ÄÄ Module level is first
³ ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±  ³  and in uppercase;
³ ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±  ³  procedures indented.
³                                ³
³ XXX is xxxxxxxxxxxxxxxx ÄÄÄÄÄÄÄÄ Describes selected item.
³                                ³
³  <Edit in Active>    <Delete> ÄÄ Choose whether to edit
³                                ³  or delete selected item.
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If you choose <Edit in Active>, QBasic displays the
procedure in the active window.
.context hidSearchFind
:nFind Command Dialog
Use to find a specific string of text.
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Find ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                   ³  Enter string or use
³ Find What: ±±±±±±±±±±±±±±±±±±±± ÄÄÄ string already here.
³                                   ³
³ ± Upper/Lowercase ± Whole Word ÄÄÄÄ Select search type.
³                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  Then choose <OK>.

Select Upper/Lowercase for a case-sensitive match, or
Whole Word to exclude matches within words or strings.
Whole-word searches recognize a match only when the target
text is surrounded by blanks, punctuation, or other special
characters. The search string can be 127 characters long.
.context hidSearchChange
:nChange Dialog
Use to replace one string of text with another.
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Change ÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                   ³  Enter string or use
³ Find What: ±±±±±±±±±±±±±±±±±±±± ÄÄÄ string already here.
³                                   ³
³ Change To: ±±±±±±±±±±±±±±±±±±±± ÄÄÄ Enter replacement.
³                                   ³
³ ± Upper/Lowercase ± Whole Word ÄÄÄÄ Select search type.
³                                   ³
³ <Find and Verify>   <Change All> ÄÄ Choose whether to
³                                   ³  review changes or
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  make all changes.

Select Upper/Lowercase for a case-sensitive match, or
Whole Word to exclude matches within words or strings.
Whole-word searches recognize a match only when the target
text is surrounded by blanks, punctuation, or other special
characters. Replacement text can be 127 characters long.
.context hidConfirm
:nChange Dialog
A match has been found and is highlighted in the active
window. You can:
  ş Choose <Change> to make the replacement and continue
    searching.
  ş Choose <Skip> to leave the text unchanged and continue
    searching.
  ş Choose <Cancel> to leave the text unchanged and stop
    searching.
.context hidOptnsDisplay
:nDisplay Dialog
Use to customize the QBasic screen.
                 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄDisplayÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                 ³ ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Colors ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿³
                 ³                     Foregrnd  Backgrnd ³
                 ³ ± Normal Text       ±±±±±±±±  ±±±±±±±± ³
                 ³                     ±±±±±±±±  ±±±±±±±± ³
Colors you pick ÄÄ± Current Statement ±±±±±±±±  ±±±±±±±± ³
here will        ³                                        ³
highlight text ÄÄÄ± Breakpoint Lines                     ³
during debugging.³                                        ³
                 ³ ÚÄÄÄÄÄÄÄÄÄÄDisplay OptionsÄÄÄÄÄÄÄÄÄÄÄÄ¿³
                 ³   ± Scroll Bars          Tab Stops: ±  ³
                 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Hides or displays    ³     Enter number of spaces you  ³
scroll bars on       ³     want Tab to advance cursor.ÄÙ
window display.ÄÄÄÄÄÄÙ

To set options:
  1. Press Tab to move the cursor to the Colors or Display
     Options box.
  2. Use the direction keys to select a color or display
     option.
  3. Choose <OK> or press Enter to save the options you
     selected.

Options settings are saved and remain in effect the next
time you start QBasic.
.context MSG_SearchPathInterp
:nHelp Path Dialog
QBasic searches for the help file QBASIC.HLP in the
directories you indicate in this dialog box. You don't need
to set the Help path if you have done so with the PATH
environment variable in DOS or if QBASIC.HLP is in the
current directory.
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Help Path ÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                       ³
³  Location (path) of QBASIC.HLP file:  ³
³                                       ³  Enter the drive
³      ±±±±±±±±±±±±±±±±±±±±±±±±±±± ÄÄÄÄÄÄ and directory
³                                       ³  where QBASIC.HLP
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  is located.

Tip: If QBasic cannot find QBASIC.HLP, check to make
     sure that you entered the correct directory name.
.comment ------------------------------------------------
.comment   End of Dialog Box Help - UIHELPID.H,  900-921
.comment ------------------------------------------------
.context m.f
.context m.e
.context m.v
.context m.s
.context m.r
.context m.d
.context m.o
.context m.h
:nQBasic Menu Bar
Using the QBasic menus and commands:

  ş To activate menus and commands, press the highlighted
    letter or click a menu or command with the mouse.
  ş To move between menus and commands, use the direction
    keys or the mouse.
.comment ------------------------------------------------
.comment   UI Help for Menu Commands and Dialog Support
.comment ------------------------------------------------
.context MSG_HelpFileNew
:nNew Command
Use to create a new program. A dialog box will appear if
you already have an existing program open. Then:
  ş Choose <Yes> to save the existing program.
  ş Choose <No> to close the program without saving it.
  ş Choose <Cancel> to cancel the New command and return
    to the existing program.

Tip: Use the Open command to load an existing program.
.context MSG_HelpFileOpen
:nOpen Command
Use to load an existing program so you can run it
or make changes to it.

Use the New command to create a new program.

 Note: To open a file created with GW-BASIC or BASICA, the
       file must be saved from GW-BASIC or BASICA with the
       ,A option.
.context MSG_HelpFileSave
:nSave Command
Use to save the current version of your program.

QBasic asks you for a name if you haven't saved the program
previously. If an existing program has the same name as the
program being saved, the existing program is overwritten.
.context MSG_HelpFileSaveAs
:nSave As Command
Use to save your program as a file. To preserve the
previous version of your program, rename it in the
File Name text box.
.context MSG_HelpFilePrint
:nPrint Command
Use to print all or part of a program or Help topic.

You can print:
  ş Selected text.
  ş The contents of the active window.
  ş The entire current program (including procedures).

QBasic prints to the printer connected to the LPT1 device
on your computer.

Tip: Select text in your program or the Help window
     before you choose the Print command. Place the
     cursor at the beginning of the text you want to
     print, press Shift+direction keys until all the text
     is highlighted, then choose the Print command.
.context MSG_HelpFileExit
:nExit Command
Use to leave the QBasic environment.

If your program file has changed since you last saved it,
QBasic displays a dialog box.
  ş Choose <Yes> to save your program, including changes.
  ş Choose <No> to discard your changes.
  ş Choose <Cancel> to cancel the Exit command and return
    to your program.
.context MSG_HelpEditCut
:nCut Command
Use Cut (or press Shift+Del) to remove selected text and
put it on the Clipboard, a temporary holding area.

You can then use Paste (Shift+Ins) to insert the text at
a new position in the active window. You can also open a
new or existing program file and insert the text.

The text is still on the Clipboard and can be pasted again.
Each time you cut or copy a piece of text, the new text
replaces any text on the Clipboard.

Tip: To select text, place the cursor at the beginning
     of the text and press the Shift+direction keys.
     To remove selected text without copying it to the
     Clipboard, press Del.
.context MSG_HelpEditCopy
:nCopy Command
Use Copy (or press Ctrl+Ins) to copy selected text to the
Clipboard. The original text is unchanged.

You can then use Paste (Shift+Ins) to insert the text
into the active window. You can also open a new or
existing program file and insert the text.

Tip: To select text, place the cursor at the beginning
     of the text and press the Shift+direction keys.

The text is still on the Clipboard and can be pasted again.
Each time you cut or copy a piece of text, the new text
replaces any text on the Clipboard.
.context MSG_HelpEditPaste
:nPaste Command
Use Paste (or press Shift+Ins) to insert a block of text
from the Clipboard at any point in the active window.

To insert text, place the cursor where you want the text
to be inserted and choose Paste.

To replace one piece of text with another, select the text
to replace and choose Paste.

Tip: To put text on the Clipboard, use Cut or Copy. After
     you insert text using Paste, the Clipboard still
     contains the text, and it can be pasted again.
.context MSG_HelpEditClear
:nClear Command
Use Clear (or press Del) to delete selected text without
copying it to the Clipboard. The Clipboard's contents are
unchanged.
.context MSG_HelpEditNewSub
:nNew SUB Command
Use to create a SUB procedure.

Enter a name for the procedure in the New SUB dialog box.
QBasic inserts SUB and END SUB statements for the
procedure and displays it in the View window.

If you want to view or edit other parts of the program,
use the SUBs command from the View menu (or press F2).

Tip: You can also create a SUB procedure by using the
     QBasic keyword SUB.
.context MSG_HelpEditNewFunc
:nNew FUNCTION Command
Use to create a FUNCTION procedure.

Enter a name for the procedure in the New FUNCTION dialog
box. QBasic inserts FUNCTION and END FUNCTION statements
for the procedure and displays it in the View window.

If you want to view or edit other parts of the program,
use the SUBs command from the View menu (or press F2).

Tip: You can also create a FUNCTION procedure by using
     the QBasic keyword FUNCTION.
.context MSG_HelpViewSubs
:nSUBs Command
Use to view or edit a SUB or FUNCTION procedure, or
to delete a procedure.

Tip: To view or edit two different SUB or FUNCTION
     procedures at the same time, choose Split from the
     View menu, then use the SUBs command to display the
     procedures in each of the windows.
.context MSG_HelpViewSplit
:nSplit Command
Use to divide the View window horizontally and work on two
parts of a program at the same time.

Use F6 and Shift+F6 to move between the windows:
  ş F6 moves the cursor down through the windows.
  ş Shift+F6 moves the cursor up.

To close a second View window, place your cursor in the
window that you want to keep active, and choose Split again.

To size the active window with a mouse, drag the window
boundary up or down.

To size the active window from the keyboard, use:
  ş Alt+Plus(+)  to expand it one line.
  ş Alt+Minus(-) to shrink it one line.
  ş Ctrl+F10     to expand it to fill the screen, or return
                 it to its former size.
.context MSG_HelpViewOutputScreen
:nOutput Screen Command
Use Output Screen (or press F4) to view the program
output screen. The output screen displays the results
of a program run in the QBasic environment.

Press any key to return to QBasic after viewing the
output screen.
.context MSG_HelpSearchFind
:nFind Command
Use to search for a text string. You can request a
case-sensitive match or a whole-word match.

To change a string, use the Change command.
.context MSG_HelpSearchChange
:nChange Command
Use to replace one text string with another.

You can:
  ş Use a case-sensitive or whole-word search.
  ş Check each replacement before the change is made.
  ş Make all replacements without checking them.
.context MSG_HelpSearchNext
:nRepeat Last Find Command
Use Repeat Last Find (or press F3) to repeat the search
performed by the most recent Find or Change command.

If no Find or Change command has been executed since you
started QBasic, Repeat Last Find searches for the next
occurrence of:
  ş The word the cursor is on.
  ş The word to the cursor's left, if the cursor isn't
    on a word.
.context MSG_HelpRunStart
:nStart Command
Use Start (or press Shift+F5) to start running a program
beginning with the first executable statement in the main
module.

If you stop a program while it is running, Start clears any
data you entered and starts the program from its beginning.
.context MSG_HelpRunRestart
:nRestart Command
Use to prepare a program to start over from the beginning.
Restart clears any data entered while the program was
running and highlights the first executable statement.
.context MSG_HelpRunContinue
:nContinue Command
Use Continue (or press F5) to resume running a program
after it has stopped. Continue does not clear data you
entered while the program was running and begins the
program from the last statement executed, rather than
from the beginning.

Continue is often used to resume program execution after
a breakpoint.
.context MSG_HelpDebugStep
:nStep Command
Use Step (or press F8) to run a single statement in your
program. Step allows you to move through the execution
of a program, including procedures, one step at a time.
.context MSG_HelpDebugPStep
:nProcedure Step Command
Use Procedure Step (or press F10) to run a single statement
in your program and to run a procedure call and the
procedure it calls as a single statement.

Procedure Step, like the Step command, allows you to move
through the execution of a program one step at a time, but
it saves you from stepping through procedures that you
know work correctly.
.context MSG_HelpDebugTraceOn
:nTrace On Command
Use to highlight each statement in your program as it
executes. This lets you observe the general flow of your
program. Press Ctrl+Break to suspend program execution.
.context MSG_HelpDebugToggleBp
:nToggle Breakpoint Command
Use Toggle Breakpoint (or press F9) to turn breakpoints
on and off. Breakpoints are markers placed on statements
in your program. If you run your program and it encounters
a breakpoint, the program stops on that statement. QBasic
highlights the breakpoint line.

To turn a breakpoint on and off:
  1. Move the cursor to the line you want the breakpoint
     on, or to a highlighted breakpoint line.
  2. Choose Toggle Breakpoint (or press F9).

Use a breakpoint to pause your program at a point where
you suspect problems, then:
  ş Print the values of variables in the Immediate window.
  ş Single step your program from the breakpoint forward.
.context MSG_HelpDebugClearAllBp
:nClear All Breakpoints Command
Use to remove all breakpoints from your program.

Use Toggle Breakpoint (or press F9) to turn individual
breakpoints off.
.context MSG_HelpDebugSetNextStmt
:nSet Next Statement Command
Use to change the program execution sequence so the next
statement executed is the one the cursor is on.
.context MSG_HelpOptionsDisplay
:nDisplay Command
Use to control:
  ş Screen colors.
  ş Scroll bars in windows.
  ş The number of spaces the Tab key advances the cursor.

Display settings are saved and remain in effect the next
time you start QBasic.
.context MSG_HelpOptionsPaths
:nHelp Path Command
Use to change the directories QBasic searches to find
the QBasic Help file, QBASIC.HLP.
.context MSG_HelpOptionsSyntax
:nSyntax Checking Command
Use to turn Syntax Checking on and off. When Syntax
Checking is on, QBasic does the following as you enter
each line of code:
  1. Checks the line for syntax errors.
  2. Formats the line.
  3. Translates the line to executable form if the syntax
     is correct.
.context MSG_HelpHelpIndex
:nIndex Command
Use to display the Help index. The Help index is an
alphabetical list of Help topics, including Basic
language keywords. Each term in the index is linked
to additional information.

To get help:
  1. Choose the Index command from the Help menu.
  2. Press the key corresponding to the item's first
     letter.
  3. Move the cursor to the item you want help on, then
     press F1.
.context MSG_HelpHelpContents
:nContents Command
Use to display the Help table of contents. The Help table
of contents provides a topical guide to the information in
QBasic Help.

To get help on any item in the table of contents:
  1. Choose the Contents command from the Help menu.
  2. Press the letter key corresponding to the first letter
     of the item. Repeat until the cursor is on the topic
     you want help on.
  3. Press F1.
.context MSG_HelpHelpSyntax
:nTopic Command
Use to display information on a topic determined by the
current location of the cursor. The topic the cursor is
on appears as part of the command.

You can also display topic Help by pressing F1 or clicking
the right mouse button.
.context MSG_HelpHelpHelp
:nUsing Help Command
Use to display the Using Help topic. Using Help describes
how to use the mouse or keyboard to get help on an item
displayed on the QBasic screen.
.context MSG_HelpHelpAbout
:nAbout Command
Use to display the version number and copyright information
for QBasic.
.comment ****************************************************************
.comment Error Message Help - QBasic                                    *
.comment  This file contains all the error message help. Help on menu   *
.comment  dialogs and related messages can be found in environ.src.     *
.comment ****************************************************************
.comment * 01/10/90 Cleaned comments.
.comment *    -- JeffWe
.comment ****************************************************************
.context -9999
:nTranslation momentarily stopped
QBasic has stopped doing an item-by-item translation of the
program line at the highlighted item. The error is
ordinarily to the left of the item. You could:
  ş Substitute an item suggested in the dialog box.
  ş Correct any misspelled keywords.
  ş Move the cursor to a keyword in the statement and press
    F1 to see the correct syntax for the keyword.
.context QB_ER_NF
.context ER_NF
:nNEXT without FOR
Each NEXT statement must have a matching FOR statement.

ERR code: 1
.context QB_ER_SN
.context ER_SN
:nSyntax error
The most common cause of this error is an incorrectly
typed Basic keyword or argument. Check to make sure the
program line is correct.

ERR code: 2
.context QB_ER_RG
.context ER_RG
:nRETURN without GOSUB
The program just executed a RETURN statement without
having executed a matching GOSUB statement.

ERR code: 3
.context QB_ER_OD
.context ER_OD
:nOut of DATA
A READ statement has been executed but there are no DATA
statements with unread data remaining in the program.

ERR code: 4
.context QB_ER_FC
.context ER_FC
:nIllegal function call
You are attempting to give an improper or out-of-range
argument to a Basic statement. Examples of such errors are:
  ş A negative number is raised to a power that is not
    an integer.
  ş A negative record number is given when using GET or PUT.
  ş An I/O function or statement (LOC or LOF, for example)
    is performed on a device that does not support it.
  ş Strings are concatenated to create a string greater
    than 32,767 characters in length.
  ş A BLOAD or BSAVE operation is directed to a non-disk
    device.

ERR code: 5
.context QB_ER_OV
.context ER_OV
:nOverflow
The result of a calculation or data-type conversion
is too large for the given data type.

ERR code: 6
.context QB_ER_OM
.context ER_OM
:nOut of memory
More memory was required than is available. To correct this:
  ş Exit QBasic and reduce the number of DOS buffers, memory
    resident programs, or loaded device drivers. Then
    reboot your computer.
  ş Make your program smaller.
  ş Reduce the number or size of arrays.
  ş Reduce the stack size by using the CLEAR statement.
  ş Reduce the number of variables.

ERR code: 7
.context QB_ER_UL
.context ER_UL
:nLabel not defined
A line label is referred to (in a GOTO statement, for
example), but does not occur in the program.

ERR code:  8
.context QB_ER_SOR
.context ER_SOR
:nSubscript out of range
An array element was referred to with a subscript that was
outside the dimensions of the array, or an element of an
undimensioned dynamic array was accessed. Check that the
array is dimensioned and check the bounds of the array.

You may also get this error if the array size exceeds 64K.
Reduce the size of the array.

ERR code: 9
.context ER_DD
:nDuplicate definition
This error occurs if you try to change the dimensions of a
static array while your program is running. To correct this,
declare the array as dynamic using the REDIM statement.

This error also occurs if you try to change the dimensions
of a dynamic array using the DIM statement without first
deallocating the array. To correct this, add an ERASE
statement before dimensioning the array.

ERR code: 10
.context QB_ER_DD
:nDuplicate definition
You are attempting to create a new element in your program
and have given it a name that is already being used.

For example:
  ş A CONST statement uses the same name as an existing
    variable.
  ş A new variable or procedure has the same name as an
    existing procedure.

Starting a variable name with the letters "FN" is another
way to generate this error, because FN is used exclusively
with DEF FN.
.context QB_ER_DV0
.context ER_DV0
:nDivision by zero
This error can be caused by dividing by zero in an
expression.

ERR code: 11
.context QB_ER_ID
.context ER_ID
:nIllegal in direct mode
The highlighted statement is valid only within a program
and cannot be used in the Immediate window. In general,
the following statements and metacommands cannot be used
in the Immediate window:
  ş COMMON, CONST, DATA, DECLARE, DIM, OPTION, SHARED,
    STATIC, and TYPE
  ş $DYNAMIC, $STATIC metacommands
  ş DEF FN...END DEF, ELSE IF, END IF, END TYPE
    FUNCTION...END FUNCTION, REDIM, and SUB...END SUB

ERR code: 12
.context QB_ER_TM
.context ER_TM
:nType mismatch
The variable is not of the required type. For example, you
are trying to use the SWAP statement with a string variable
and a numeric variable, or with two numeric variables of
different types.

ERR code: 13
.context QB_ER_OS
.context ER_OS
:nOut of string space
The string space needed for your string variables exceeds
the amount available. To get more string space:
  ş Reduce the number of variables.
  ş Reduce the number or size of arrays of strings.
  ş Reduce the stack size. Use the CLEAR statement to
    resize the stack.

ERR code: 14
.comment -------------
.comment   15 unused
.comment -------------
.context QB_ER_BS
.context ER_BS
:nString formula too complex
Either a string formula is too long, or you have specified
more than 15 string variables in an INPUT statement. Break
the formula or INPUT statement into smaller parts.

ERR code: 16
.context QB_ER_CN
:nQBasic cannot continue
Cannot continue is a prompt that may occur while you are
debugging. While your program was suspended (at a
breakpoint, for example) you made a change to the program
that has implications throughout the program. You may have
changed the dimensions of an array, changed procedure
arguments, or edited some other declarative statement. Use
the dialog box and either:
   ş Choose <OK> to keep the change and restart the program.
   ş Choose <Cancel> to undo the change in your program
     text. (You can do this if restarting interferes with
     your debugging strategy.)
.context ER_UF
.context ER_CN
.context ER_US
.context QB_ER_UE
.context ER_UE
.context QB_ER_CaseElse
.context ER_CaseElse
:nUser-Generated Error
You have used an ERROR statement to generate this error.

ERR codes: 17, 18, 35, 39
.context QB_ER_UF
:nQBasic function not defined
The function defined by DEF FN does not exist, which
can indicate one of the following conditions:
   ş The DEF FN function is undefined.
   ş The DEF FN function is attempting to call itself
     recursively.
.context QB_ER_NR
.context ER_NR
:nNo RESUME
The end of the program was encountered while the program
was executing an error-handling routine. Add a RESUME
statement in the error-handling routine.

ERR code: 19
.context QB_ER_RE
.context ER_RE
:nRESUME without error
A RESUME statement was executed, but there is no active
error-handling routine.

ERR code: 20
.comment -------------
.comment  21-23 unused
.comment -------------
.context ER_DTO
:nDevice timeout
The program did not receive information from a device, such
as the printer, within the timeout period.

ERR code: 24
.context QB_ER_DTO
:nDevice timeout
QBasic did not receive information from a device, such as
the printer, within the timeout period:
  ş If you are attempting to print, make sure the printer
    is attached to the device LPT1.
.context ER_DF
:nDevice fault
A device has returned a hardware error, which can indicate
one of the following conditions:
   ş If you are attempting to print a file, the printer
     is not attached to the device LPT1.
   ş If you are transmitting data to a communications file,
     the signals being tested with the OPEN COM statement
     were not received within the timeout period.

ERR code: 25
.context QB_ER_DF
:nQBasic device fault
QBasic has detected a fault at the printer. Make sure that:
   ş The printer online indicator light is still on.
   ş The printer power is still on.
   ş The printer cable is securely connected to the printer
     and the computer.
.context ER_FN
.context QB_ER_FN
:nFOR without NEXT
Each FOR statement must have a matching NEXT statement.

ERR code: 26
.context QB_ER_OP
.context ER_OP
:nOut of paper
The printer is out of paper, or it is not turned on.

ERR code: 27
.comment -------------
.comment   28 unused
.comment -------------
.context QB_ER_WH
.context ER_WH
:nWHILE without WEND
Each WHILE statement must have a matching WEND statement.

ERR code: 29
.context QB_ER_WE
.context ER_WE
:nWEND without WHILE
Each WEND statement must have a matching WHILE statement.

Also, verify that other control structures within the
WHILE...WEND structure are correctly matched. For
example, an IF without a matching ENDIF inside the
WHILE...WEND structure will generate this error.

ERR Code: 30
.comment -------------
.comment  31-32 unused
.comment -------------
.context QB_ER_DL
.context ER_DL
:nDuplicate label
Two program lines were assigned the same line number or
label. Each line number or label must be unique.

Change the highlighted line number or label, or use the Find
command from the Search menu to locate the duplicate number
or label, then change that number or label to be unique.

ERR code: 33
.comment -------------
.comment   34 unused
.comment -------------
.context QB_ER_US
:nQBasic subprogram not defined
You are attempting to call a SUB procedure that QBasic
cannot find.

Press F2 to view the SUB and FUNCTION procedures that are
available.
.context QB_ER_AC
.context ER_AC
:nArgument-count mismatch
An incorrect number of arguments was used in a
SUB or FUNCTION procedure call.

Compare the DECLARE statement for the SUB or FUNCTION
procedure with the CALL statement to make sure the argument
list has the same number of items in both cases.

ERR Code: 37
.context QB_ER_UA
.context ER_UA
:nArray not defined
Your program is attempting to use an array that is not
currently defined.

Verify that the array name is correct, and define the array
with a DIM or REDIM statement.

ERR code: 38
.comment ----------
.comment 39 unused
.comment ----------
.context QB_ER_VarReq
.context ER_VarReq
:nVariable required
QBasic may have encountered an INPUT, LET, READ, or SHARED
statement without a variable argument. QBasic may also have
encountered a GET or PUT statement which didn't specify a
variable when an operation was performed on a file opened
in binary mode.

ERR code: 40
.comment -------------
.comment  41-49 unused
.comment -------------
.context QB_ER_FOV
.context ER_FOV
:nFIELD overflow
A FIELD statement attempted to allocate more bytes than
were specified for the record length of a random file.
Check the OPEN statement for the file to verify the
record length.

ERR code: 50
.context QB_ER_IER
.context ER_IER
:nInternal error
An internal error occurred in QBasic that should be
reported to Microsoft.

ERR code: 51
.context QB_ER_BFN
.context ER_BFN
:nBad file name or number
This error may occur because a statement or command refers
to a file with a file number or name that is not specified
in the OPEN statement or is out of the range of file numbers
(valid range is 1-255) specified earlier in the program.

ERR code: 52
.context ER_FNF
:nFile not found
An OPEN or RUN or other Basic statement refers to a file
that does not exist.

ERR code 53
.context QB_ER_FNF
:nQBasic File not found
In the Open command dialog box, you specified a file
that does not exist. Check to see that the filename is
spelled correctly, and that you chose the correct
drive and directory.

ERR code 53
.context QB_ER_BFM
.context ER_BFM
:nBad file mode
The error may have occurred because:
   ş A PUT or GET statement specified a sequential file.
   ş A FIELD statement specified a file not opened for
     random access.
   ş A PRINT # statement specified a sequential file opened
     for input.
   ş An INPUT # statement specified a file opened for
     output or appending.
   ş You attempted to open a QuickBasic binary format file.

ERR code: 54
.context QB_ER_FAO
.context ER_FAO
:nFile already open
This error is caused by one of the following conditions:
   ş A sequential-output-mode OPEN statement has been
     executed for a file that is already open.
   ş A KILL statement refers to an open file.

ERR code: 55
.context QB_ER_FSA
.context ER_FSA
:nFIELD statement active
A GET or PUT statement specified a record variable in a
file for which FIELD statements had been executed.

GET or PUT with a record-variable argument can be
used only on a file if no FIELD statements have been
executed for the file.

ERR code: 56
.context ER_IOE
:nDevice I/O error
An input or output error occurred while your program was
using a device, such as the printer or disk drive.

ERR code: 57
.context QB_ER_IOE
:nQBasic device I/O error
You used the File menu's Print command and the printer
malfunctioned. Check the printer.
.context QB_ER_FAE
.context ER_FAE
:nFile already exists
The filename specified in a NAME statement is identical
to the name of a file that already exists. Specify another
filename in the NAME statement, change directories, or
rename or delete the existing file.

ERR code: 58
.context QB_ER_BRL
.context ER_BRL
:nBad record length
The length of a record variable in a GET or PUT statement
did not match the record length specified in the
corresponding OPEN statement.

ERR code: 59
.comment -------------
.comment   60 unused
.comment -------------
.context ER_DFL
:nDisk full
There wasn't enough room on the disk to complete a
PRINT #, PRINT USING #, WRITE #, CLOSE, or PUT operation.

ERR code: 61
.context QB_ER_DFL
:nQBasic disk full condition
There isn't room on the specified disk to save the file.
Save the file to another disk.

.context QB_ER_RPE
.context ER_RPE
:nInput past end of file
An INPUT # statement read from an empty file or from
a file in which all data has already been read.

To avoid this error, use the EOF function to detect the end
of file.

ERR code: 62
.context QB_ER_BRN
.context ER_BRN
:nBad record number
The record number in a PUT or GET statement was less than
or equal to zero.

ERR code: 63
.context ER_IFN
:nBad file name
A filename does not follow the appropriate naming
convention for BLOAD, BSAVE, KILL, or OPEN (for example,
the filename has too many characters).

ERR code: 64
.context QB_ER_IFN
:nBad file name
The filename you specified either contains too many
characters or characters that are not allowed in filenames.
.comment -------------
.comment  65-66 unused
.comment -------------
.context ER_TMF
:nToo many files
You have exceeded the number of file operations DOS allows
in a root directory. If your program is opening, closing,
and/or saving files in the root directory, change your
program so it uses a subdirectory.

ERR code: 67
.context QB_ER_TMF
:nQBasic too many files limit
Your program has opened more disk files than QBasic can
handle. You must close one or more of the open files
before you can use QBasic commands.

The easiest way to do this is with the Basic CLOSE
statement:
   1. Move the cursor to the Immediate window.
   2. Enter CLOSE on the first available text line.
   3. Press Enter to execute the statement.

You can then execute QBasic commands. If your program was
running, you will have to restart it.
.context ER_DNA
:nDevice unavailable
The device you are attempting to access is not online or
does not exist.

ERR code: 68
.context QB_ER_DNA
:nQBasic device unavailable
You are attempting to open a file on a device that does not
exist in your system. Check the list of available device
names in the Dirs/Drives list box in the Open dialog box
and use one of those.
.context QB_ER_CBO
.context ER_CBO
:nCommunication-buffer overflow
During remote communications, the receive buffer
overflowed.

The size of the receive buffer is set by the RB option
in the OPEN COM statement. To avoid this error, you can:
  ş Check the buffer more frequently using the LOC
    function.
  ş Empty the buffer more often using the INPUT$ function.

ERR code: 69
.context ER_PRM
:nPermission denied
An attempt was made to write to a write-protected disk, or
to access a locked file.

ERR code: 70
.context QB_ER_PRM
:nQBasic permission denied
You are attempting to overwrite a read-only file or there is
a write-protect tab on the disk you are trying to write to.

To avoid the read-only conflict, use a different filename.
Remove the tab or use a different disk if the write-protect
tab is present.
.context ER_DNR
.context QB_ER_DNR
:nDisk not ready
The disk-drive door is open, or no disk is in the specified
drive. Insert a disk in the drive, close the drive door, and
retry the operation.

ERR code: 71
.context ER_DME
:nDisk-media error
Disk-drive hardware has detected a physical flaw on the
disk.

ERR code: 72
.context QB_ER_DME
:nQBasic Disk-media error
QBasic does not recognize the format of the disk it is
attempting to use. Use a different disk or exit QBasic
and reformat the current disk.
.context QB_ER_ADF
.context ER_ADF
:nFeature unavailable
You may be attempting to use a feature of another version
of Basic that is not available with Microsoft QBasic.

ERR code: 73
.context QB_ER_RAD
.context ER_RAD
:nRename across disks
You attempted to rename a file with a new drive designation.
You cannot rename a file with a new drive designation in
QBasic.

ERR code: 74
.context ER_PAE
.context QB_ER_PAE
:nPath/file access error
During an OPEN, MKDIR, CHDIR, or RMDIR operation, the
operating system was unable to make a correct connection
between the path and filename.

In the QBasic environment, make sure the file specification
you entered in the text box is formatted correctly. Any
filename can contain a drive name and a full or partial
path.

This error can also occur when you try to save a file which
would replace an existing read-only file.

ERR code: 75
.context ER_PNF
:nPath not found
During an OPEN, MKDIR, CHDIR, or RMDIR operation, the
operating system was unable to find the path specified.

ERR code: 76
.context QB_ER_PNF
:nQBasic Path not found condition
DOS was unable to find the path that you specified in
the dialog box for the Open command, the Save command,
or the Save As command. Check that you typed the
path correctly.
.comment -------------------------------------------
.comment  Last of runtime errors - found at top of
.comment  p. 5 in printout of BIGPIC.ERR
.comment -------------------------------------------
.context MSG_OutOfStack
:nOut of stack space
This error can occur when there are too many active
subroutine, FUNCTION, and SUB calls, or when a recursive
FUNCTION procedure nests too deeply.

Change the structure of your program, or use the
CLEAR statement to increase the program's allotted
stack space.
.comment -----------------------------------------------
.comment  User Interface Related Messages that could be
.comment  described in user's guide error message
.comment  appendix.
.comment -----------------------------------------------
.context MSG_CantCont
:nCannot continue
While paused during debugging (at a breakpoint, etc.),
you made a change that prevents execution from continuing.
You may have redimensioned an array, changed procedure
arguments, or edited some other declarative statement.
Use the dialog box and either:
  ş Choose <OK> to keep the change and restart the program.
  ş Choose <Cancel> to undo the change in your program
    text. (You can do this if restarting interferes with
    your debugging strategy.)
.comment -----------------------------------------------
.comment  Following are non-runtime errors.
.comment -----------------------------------------------
.context MSG_DupPrs
:nDuplicate procedure names in file
The file you attempted to open contains two SUB or FUNCTION
procedures with the same name. Use an editor to rename
one of them, then open your file in QBasic.
.comment -----------------------------------------------
.comment  General User Interface messages
.comment -----------------------------------------------
.context MSG_Overwrite
:nOverwrite existing file
Choose <Yes> only if you are sure that by overwriting the
contents of the file on disk with the file contents in
memory you won't lose valuable information.
Otherwise:
  ş Choose <No> to redisplay the dialog box and enter a
    new, unique filename for saving the file in memory.
  ş Choose <Cancel> to stop the command, leaving everything
    as it was before you chose the command.
.context MSG_DelProc
:nDelete procedure confirmation
Before deleting a procedure, the SUBs command verifies that
you want to delete the procedure from the module. Either:
  ş Choose <OK> to delete the procedure.
  ş Choose <Cancel> to stop the deletion, leaving everything
    as it was before you chose the command.
.context MSG_MakeRem
:nBlank lines not allowed
Ordinarily the SUB or FUNCTION statement that begins a
procedure is the first line in the View window. When you
try to put a blank line above the SUB or FUNCTION statement,
QBasic transforms the blank line into a comment line.
.context MSG_NotSaved
.context MSG_NotSavedAll
:nFile not saved
Your file has either never been saved or has not been saved
since it last changed. Either:
  ş Choose <Yes> to save the file, preserving your
    changes.
  ş Choose <No> to discard your changes.
  ş Choose <Cancel> to cancel the command, leaving
    everything as it was before you chose this command.
.context MSG_BadNextStmt
:nCannot cross procedure boundary
During debugging, you used the Set Next Statement command to
specify a statement that is in a procedure other than
the one where program execution is suspended. In this case,
QBasic ignores the Set Next Statement command.

To continue debugging, move the suspended procedure into the
View window. You can then use the Set Next Statement command
to start running from any statement in that procedure.
.context MSG_MustSpecifyName
:nSpecify name
You chose <OK> in a dialog box when the contents of the
text box were blank. Type a module or procedure name in
the text box and chose <OK> again.
.context MSG_DataMoved
:nDATA statements were moved
QBasic requires that all DATA statements in a program be in
the module-level code. QBasic automatically moves DATA
statements to the module level.
.context MSG_NoSearchString
:nNo search string
The Find What text box was empty when you executed a
Find or Change command. Choose the command again and
enter a text string before choosing <OK>.
.context MSG_MatchNotFound
:nMatch not found
QBasic could not find the string specified.

The cursor remains at the location where you started the
search.
.context MSG_ChangeComplete
:nChange complete
The search and replace task is complete. The cursor is
back at the point where the search started.
.context MSG_ReqSub
:nSUB or FUNCTION required
You selected the module name from the SUBs command
dialog box. Select a SUB or FUNCTION procedure instead.
.context MSG_SwitchDisks
:nInsert diskette
You have referred to your floppy disk drive as A: when
it is named B:, or B: when it is named A:.

Make sure the file you want this command to operate on
is on a disk in the floppy disk drive, then choose <OK>.
.context MSG_CantSetTabs
:nCannot set Tabs
When you have a file open that contains a previously set
tab stop, it cannot be changed with the Tab Stops option
from the Display command. Save your file, then use the
New command to clear the QBasic View window.  Use the
Display command to set the tab stop, then reopen your file.
.context MSG_OutNearMem
:nOut of data space
QBasic ran out of room in memory for data, variables, and
some other information. Try modifying your data space
requirements as follows:
  ş  Use a smaller file buffer in the OPEN statement's
     LEN clause.
  ş  Use the $DYNAMIC metacommand to create dynamic
     arrays. Dynamic array data can usually be much
     larger than static array data.
  ş  Use fixed-length string arrays instead of
     variable-length string arrays.
  ş  Use the smallest data type that accomplishes
     your task. Use integers whenever possible.
  ş  Use CLEAR to modify the size of the stack.
  ş  Do not use source lines longer than 256 characters.
     Such lines require allocation of additional
     text buffer space.
.context MSG_ModTooLarge
:nModule-level code too large
The size of your module-level code exceeds QBasic's internal
limit. Try moving some of the code into SUB or FUNCTION
procedures.
.context MSG_ProcTooLarge
:nProcedure too large
The size of the current procedure exceeds QBasic's internal
limits. Make the procedure smaller by dividing it into
several procedures.
.comment -----------------------------------------------
.comment     Section 2: QBI Parser Related Messages
.comment -----------------------------------------------
.context MSG_IdTooLong
:nIdentifier too long
The indicated identifier is longer than QBasic allows.
Identifiers, such as variable names, must not be longer
than 40 characters.
.context MSG_BadId
:nInvalid identifier
You have used a character that is not valid in an
identifier. Make sure that:
  ş DEF FN procedure names contain only letters and
    numbers.
  ş FUNCTION and SUB procedure names start with a
    letter and do not contain these special characters:
    ., %, &, !, #, or $.
.context MSG_IdImp
:nIdentifier cannot end with %, &, !, #, $
Identifiers cannot end with %, &, !, #, or $.

The above suffixes are not allowed in type identifiers
or in SUB procedure names.
.context MSG_BadElemRef
:nIdentifier cannot include period
A period cannot be used in:
  ş The name of a user-defined data type.
  ş The name of an element in a user-defined type.
  ş The name of a variable dimensioned as a
    user-defined data type.

Although variable names can contain periods, it is
recommended that a period be used only as a record variable
separator. If you have programs that use a period in
variable names, you could change them to use mixed-case
instead. For example, variable ALPHA.BETA would become
AlphaBeta.
.context MSG_ExpTooComplex
:nExpression too complex
Certain internal limitations of QBasic have been exceeded.

For example, during expression evaluation, strings that are
not associated with variables are assigned temporary
locations. A large number of such strings can cause this
error to occur. Likewise, a numeric expression made up of
many complicated subexpressions can cause this error.

Try simplifying expressions or assigning strings to
variables.
.context MSG_IllegalNumber
:nIllegal number
You have used a number that is inappropriate for the
context in which it is used. For example, QBasic does not
allow you to declare a fixed-length string of zero length,
so DIM X AS STRING * 0 is illegal. An illegal number also
occurs if you declare contradictory values. For example,
using an integer data type declaration suffix with a
floating-point number (for example, 10.20%) causes this
error.
.context MSG_InvConst
:nInvalid constant
An invalid expression has been used to assign a value to a
symbolic constant.

Numeric expressions assigned to symbolic constants can
contain:
   ş Numeric literals.
   ş Previously defined symbolic constants.
   ş Any of the arithmetic or logical operators except
     exponentiation.

String expressions assigned to a symbolic constant may
consist only of a single literal string, enclosed in double
quotation marks.
.comment ------------------------------------------------
.comment       Section 3: TextMgr/ReParse errors
.comment ------------------------------------------------
.context MSG_InvModLev
:nIllegal outside of SUB, FUNCTION or DEF FN
QBasic has encountered a statement that is not
allowed in module-level code. For example, EXIT SUB, EXIT
FUNCTION, or EXIT DEF statements are not allowed in
module-level code.
.context MSG_InvMain
:nIllegal outside of SUB/FUNCTION
QBasic has encountered a statement that is not
allowed in module-level code or DEF FN functions.
.context MSG_InvProc
:nIllegal in SUB, FUNCTION, or DEF FN
The statement is not allowed inside a SUB or FUNCTION
procedure or DEF FN function.
.context MSG_InvBeforeProcDef
:nStatement cannot precede SUB/FUNCTION definition
Only comments and DEFtype statements are allowed before
a procedure definition.
.context MSG_ProcNoEnd
:nSUB/FUNCTION without END SUB/FUNCTION
The terminating statement is missing from a procedure.
.context MSG_EndNoDef
:nEND DEF without DEF
An END DEF statement has no corresponding DEF statement.
.context MSG_UndElem
:nElement not defined
You have attempted to use an element that you have not
defined previously as part of a user-defined data type.

For example, if you defined MYTYPE as containing elements
A, B, and C, and you attempted to use the variable D as
an element of MYTYPE, this message would appear.
.context MSG_UndType
:nType not defined
A variable or parameter was declared with a undefined
data type.

Use the TYPE statement to define a data type.
.context MSG_1stStmt
:nMust be first statement on the line
In block IF...THEN...ELSE constructs, IF, ELSE, ELSEIF, and
END IF can only be preceded by a line number or label.

In SELECT...END SELECT constructs, CASE and END SELECT can
be preceded only by a line number or label.
.context MSG_EndProc
:nEND SUB or END FUNCTION must be last line
You are attempting to add code after the last line in a
procedure. You must either return to the main module or
open another SUB or FUNCTION to add lines of code.
.context MSG_NoEndType
:nTYPE without END TYPE
There is no END TYPE statement associated with a TYPE
statement.
.context MSG_NoType
:nEND TYPE without TYPE
There is no TYPE statement associated with an END TYPE
statement.
.context MSG_InvInTypeBlk
:nStatement illegal in TYPE block
Only comments and AS data type clauses are allowed between
the TYPE and END TYPE statements.
.context MSG_FNstart
:nCannot start with 'FN'
You used "FN" as the first two letters of a SUB or a
FUNCTION procedure or variable name.

"FN" can only be used as the first two letters when calling
a DEF FN function.
.context MSG_NotBlock
:nOperation requires disk
You are attempting to load from, or save to, a nondisk
device such as the printer or keyboard.
.context MSG_BadMeta
:n$Metacommand error
The syntax of a metacommand is incorrect.
Metacommands must be preceded by a comment. For example,
both of the following $DYNAMIC metacommands are correct:

REM  $DYNAMIC
'  $DYNAMIC
.context MSG_NoBpCase
:nBreakpoint not allowed on CASE clause
There are some restrictions on using breakpoints to debug
SELECT...END SELECT statements. You cannot place a
breakpoint on the first statement in the CASE block or
after the END SELECT statement.

To debug a SELECT...END SELECT statement with the aid of a
breakpoint, set the breakpoint on the SELECT CASE line in
your program. Then single-step through the rest of the
statement structure.
.comment -----------------------------------
.comment    Section 4:  Scan-time errors
.comment -----------------------------------
.context MSG_OBA
:nArray already dimensioned
This error can be caused by any of the following:
  ş More than one DIM statement for the same static
    array.
  ş An attempt to change the dimensions of a dynamic
    array with a DIM statement without using the ERASE
    statement to deallocate the array first.
  ş An OPTION BASE statement that occurs after an
    array is dimensioned.
.context MSG_COM
:nMust precede executables
A COMMON statement or a DECLARE statement occurs after an
executable statement. COMMON and DECLARE statements must
appear before any executable statements. All Basic
statements are executable except the following:

    COMMON                     OPTION BASE
    CONST                      REM
    DATA                       SHARED
    DECLARE                    STATIC
    DEFtype                    TYPE
    DIM (for static arrays)    $STATIC and $DYNAMIC
.context MSG_EWI
:nEND IF without Block IF
The IF keyword that starts an IF...ENDIF block is missing.

Also check other control structures within the IF...ENDIF
block and verify that they are correctly matched. For
example, a nested IF block without a matching ENDIF
inside the outer IF...ENDIF block generates this error.
.context MSG_IWE
:nBlock IF without END IF
There is no corresponding END IF in a block IF...THEN
statement.
.context MSG_ElseWI
:nELSE without IF
An ELSE clause appears without a corresponding IF.
Sometimes this error is caused by incorrectly nested IF
statements.

Also check other control structures within the IF...ENDIF
block and verify that they are correctly matched. For
example, a nested IF block without a matching ENDIF
inside the outer IF...ENDIF block generates this error.
.context MSG_ExitScope
:nEXIT FOR not within FOR...NEXT
An EXIT FOR statement is used outside of a FOR...NEXT
statement.
.context MSG_ExitDo
:nEXIT DO not within DO...LOOP
An EXIT DO statement is used outside of a DO...LOOP
statement.
.context MSG_Do
:nDO without LOOP
The terminating LOOP keyword is missing from a DO...LOOP
statement.
.context MSG_Loop
:nLOOP without DO
The DO starting a DO...LOOP statement is missing or
or misspelled.

Also check other control structures within the DO...LOOP
structure and verify that they are correctly matched. For
example, an IF block without a matching ENDIF inside the
DO...LOOP structure generates this error.
.context MSG_Select
:nSELECT without END SELECT
The terminating END SELECT keywords are missing from a
SELECT CASE statement.
.context MSG_Case
:nCASE without SELECT
The SELECT CASE keywords starting a SELECT CASE statement
are missing or misspelled.

Also check other structures within the SELECT...END SELECT
structure and verify that they are correctly matched. For
example, an IF block without a matching END IF inside the
SELECT...END SELECT structure generates this error.
.context MSG_EndSelect
:nEND SELECT without SELECT
The SELECT CASE keywords beginning a SELECT CASE statement
are missing or misspelled.

Also check other control structures within the
SELECT...END SELECT structure and verify that they are
correctly matched. For example, an IF block without a
matching END IF inside the SELECT...END SELECT structure
generates this error.
.context MSG_InvFixStr
:nFixed-length string illegal
You cannot use a fixed-length string as a formal parameter
to a SUB or FUNCTION procedure.
.context MSG_InvTypedVar
:nTyped variable not allowed in expression
Variables of a user-defined data type cannot be passed as
arguments. For example, the following expression, where X
is a user-defined data type, is not permitted:

CALL ALPHA(X)

You can, however, pass elements of a user-defined data type
as arguments, as follows:

CALL Alpha(X.FirstEl)
.context MSG_DefNoEnd
:nDEF without END DEF
There is no corresponding END DEF in a multi-line function
definition.
.context MSG_ParmTM
:nParameter type mismatch
A SUB or FUNCTION procedure parameter data type does not
match the data type of the DECLARE statement's argument or
the calling argument.
.context MSG_ASRqd1st
:nAS clause required on first declaration
A variable that has not been declared using an AS clause is
referred to with an AS clause.
.context MSG_ASRqd
:nAS clause required
A variable declared with an AS clause is referred to
without that clause.

If the first declaration of a variable has an AS clause,
every subsequent DIM, REDIM, SHARED, or COMMON statement
that refers to that variable must have an AS clause.
.context MSG_ExpectedCase
:nIllegal placement of statements
Statements and line labels are not permitted between
SELECT CASE and the first CASE statement.

Comments and the statement separator (:) are permitted.
.context MSG_NoNumArr
:nNumeric array illegal
Elements of numeric arrays are not allowed as arguments
to VARPTR$.

Only simple variables and variable-length string array
elements are permitted.
.context MSG_InType
:nIllegal outside of TYPE block
The "element AS type" clause is permitted only within a
TYPE...END TYPE block.
.context MSG_SubCnt
:nWrong number of dimensions
An array reference contains the wrong number of dimensions.
.context MSG_DefFnCtrl
:nDEF FN not allowed in control statements
DEF FN function definitions are not permitted inside control
statements such as IF...THEN...ELSE and SELECT CASE.
.context MSG_ForIndexInUse
:nFOR index variable already in use
This error occurs when the same variable is used as the
counter argument in one FOR...NEXT statement and in a
nested FOR...NEXT statement inside that loop.  Nested
FOR...NEXT statements must use diffrent variables for
their counter arguments.
.context MSG_TypeTooLarge
.context h.pg$
:nType more than 65535 bytes
A user-defined data type cannot exceed 64K.
